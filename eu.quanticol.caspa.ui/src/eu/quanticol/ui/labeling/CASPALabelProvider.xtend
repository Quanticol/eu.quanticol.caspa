/*
* generated by Xtext
*/
package eu.quanticol.ui.labeling

import com.google.inject.Inject
import eu.quanticol.ModelUtil
import eu.quanticol.cASPA.Action
import eu.quanticol.cASPA.ActionProcess
import eu.quanticol.cASPA.Arguments
import eu.quanticol.cASPA.BooleanConstant
import eu.quanticol.cASPA.Constant
import eu.quanticol.cASPA.DistributedEventUpdateProbability
import eu.quanticol.cASPA.DistributedEventUpdateUniform
import eu.quanticol.cASPA.DistributionNatural
import eu.quanticol.cASPA.LocalSingleEventUpdate
import eu.quanticol.cASPA.Predicate
import eu.quanticol.cASPA.PredicateExpression
import eu.quanticol.cASPA.PredicateProcess
import eu.quanticol.cASPA.Process
import eu.quanticol.cASPA.ProcessExpression
import eu.quanticol.cASPA.ReferencedProcess
import eu.quanticol.cASPA.Store
import eu.quanticol.cASPA.Term
import eu.quanticol.cASPA.UniformNatural
import eu.quanticol.cASPA.UpdateExpression
import eu.quanticol.cASPA.Updates
import org.eclipse.emf.edit.ui.provider.AdapterFactoryLabelProvider
import org.eclipse.xtext.ui.label.DefaultEObjectLabelProvider
import eu.quanticol.cASPA.Bool
import eu.quanticol.cASPA.Stores
import eu.quanticol.cASPA.UpdateExpressionStoreReference
import eu.quanticol.cASPA.OutStoreReference
import eu.quanticol.cASPA.Choice
import eu.quanticol.cASPA.Parallel
import eu.quanticol.cASPA.Leaf
import eu.quanticol.cASPA.UniformReference
import eu.quanticol.cASPA.DistributionReference
import eu.quanticol.cASPA.UpdateStoreReference
import eu.quanticol.cASPA.Out
import eu.quanticol.cASPA.In
import eu.quanticol.cASPA.PredicateStoreReference
import eu.quanticol.cASPA.PredicateNot

/**
 * Provides labels for a EObjects.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#labelProvider
 */
class CASPALabelProvider extends DefaultEObjectLabelProvider {

	@Inject
	new(AdapterFactoryLabelProvider delegate) {
		super(delegate);
	}

	@Inject extension ModelUtil

	def text(Term term){
		
		var String result = "Term: (" + term.ref.cTString + ", { " 
		for(s : term.stores.stores)
			if(term.stores.stores.last.equals(s))
				result = result + s.cTString
			else
				result = result + s.cTString + ", "
			result = result + " })"
		return result
	}
	
	def text(ReferencedProcess process){
		return "References: " + process.ref.name
	}
	
	def text(ProcessExpression pe){
		return pe.cTString
	}
	
	def text(ActionProcess ap){
		return "Action: "
	}
	
	def text(PredicateProcess pp){
		return pp.cTString
	}
	
	def text(Stores s){
		return "Stores: "
	}
	
	def text(Process p){
		return "Process: " + p.name
	}
	
	def text(Store s){
		s.cTString
	}
	
	def text(Predicate p){
		return "[Predicate]: "
	}
	
	def text(UpdateExpressionStoreReference uesr){
		return uesr.cTString
	}
	
	def text(OutStoreReference osr){
		return osr.cTString
	}
	
	def text(PredicateExpression pe){
		return pe.cTString
	}
	
	def text(Constant c){
		return "value"
	}
	
	def text(Bool bc){
		return "boolean"
	}
	
	def text(Action a){
		return a.name
	}
	
	def text(Arguments a){
		return a.cTString
	}
	
	def text(Updates us){
		return us.cTString
	}
	
	def text(LocalSingleEventUpdate u){
		return "Single event: "
	}
	
	def text(DistributedEventUpdateProbability u){
		return "Distributed probability function: "
	} 
	
	def text(DistributedEventUpdateUniform u){ 
		return "Uniform probability function: "
	}
	
	def text(DistributionNatural u){ 
		return "value"
	}
	
	def text(UniformNatural u){ 
		return "value"
	} 
	
	def text(UpdateExpression u){ 
		return u.cTString
	}
	
	def text(Choice ap){
		return "+"
	}
	
	def text(Parallel ap){
		return "|"
	}
	
	def text(BooleanConstant bc){
		return "boolean"
	}
	
	def text(Leaf leaf){
		return leaf.cTString
	}
	
	def text(UniformReference ur){
		return ur.cTString
	}

	def text(DistributionReference dr){
		return dr.cTString
	}
	
	def text(UpdateStoreReference usr){
		return usr.cTString
	}
	
	def text(In in){
		return "(In arguments)"
	}
	
	def text(Out out){
		return "<Out arguments>"
	}
	
	def text(PredicateStoreReference psr){
		return psr.cTString
	} 
	
	def text(PredicateNot pn){
		return "!"
	}
}
