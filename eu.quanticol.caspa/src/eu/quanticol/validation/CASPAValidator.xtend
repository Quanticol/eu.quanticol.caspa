/*
 * generated by Xtext
 */
package eu.quanticol.validation

import com.google.inject.Inject
import eu.quanticol.cASPA.CASPAPackage
import eu.quanticol.cASPA.LocalSingleEventUpdate
import eu.quanticol.cASPA.Model
import eu.quanticol.cASPA.Predicate
import eu.quanticol.cASPA.PredicateAnd
import eu.quanticol.cASPA.PredicateComparison
import eu.quanticol.cASPA.PredicateDiv
import eu.quanticol.cASPA.PredicateEquality
import eu.quanticol.cASPA.PredicateExpression
import eu.quanticol.cASPA.PredicateMul
import eu.quanticol.cASPA.PredicateNot
import eu.quanticol.cASPA.PredicateOr
import eu.quanticol.cASPA.PredicatePlu
import eu.quanticol.cASPA.PredicateSub
import eu.quanticol.cASPA.Process
import eu.quanticol.cASPA.UpdateDiv
import eu.quanticol.cASPA.UpdateExpression
import eu.quanticol.cASPA.UpdateMul
import eu.quanticol.cASPA.UpdatePlu
import eu.quanticol.cASPA.UpdateSub
import eu.quanticol.typing.BaseType
import eu.quanticol.typing.TypeProvider
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.validation.Check
import static extension org.eclipse.xtext.EcoreUtil2.*
import static org.eclipse.emf.ecore.util.EcoreUtil.*
import eu.quanticol.cASPA.In
import eu.quanticol.cASPA.FreeVariable
import eu.quanticol.ModelUtil
import java.util.Set
import java.util.HashSet
import eu.quanticol.cASPA.SelfReference
import eu.quanticol.cASPA.Action
import eu.quanticol.cASPA.Arguments
import eu.quanticol.cASPA.Out
import eu.quanticol.cASPA.DistributedEventUpdateProbability
import eu.quanticol.cASPA.DistributedEventUpdateUniform
import eu.quanticol.cASPA.Updates
import eu.quanticol.cASPA.StoreExpression
import eu.quanticol.cASPA.PredicateStoreReference
import eu.quanticol.cASPA.OutStoreReference
import eu.quanticol.cASPA.UpdateExpressionStoreReference
import eu.quanticol.cASPA.DistributionReference
import eu.quanticol.cASPA.UniformReference

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class CASPAValidator extends AbstractCASPAValidator  {
	
	@Inject extension TypeProvider
	@Inject extension ModelUtil
	
	
	public static val PROCESS_NAMES_UNIQUE = "eu.quanticol.processNamesUnique"
	public static val WRONG_TYPE = "eu.quanticol.WrongType"
	public static val FREE_VARIABLES_UNIQUE = "eu.quanticol.freeVariablesUnique"
	public static val SELF_REFERENCE_HAS_REFERENCE = "eu.quanticol.selfReferenceHasReference"
	
	@Check
	def checkProcessNamesUnique(Process process){
		
		var processes = getContainerOfType(process, typeof(Model)).processes
		
		var count = 0
		
		for(proc : processes)
			if(proc.name.equals(process.name))
				count = count + 1
				
		if(count == 1)
			return
		else 
			error("Must have unique process names. '" + process.name + "' is repeated",
				CASPAPackage::eINSTANCE.process_Name,
				PROCESS_NAMES_UNIQUE
			)
			
	}
	
	@Check
	def checkType(Predicate predicate){
		checkExpectedBoolean(predicate.predicate, CASPAPackage.Literals::PREDICATE__PREDICATE)
	}
	
	@Check
	def checkType(PredicateOr p){
		checkExpectedBoolean(p.left, CASPAPackage.Literals::PREDICATE_OR__LEFT)
		checkExpectedBoolean(p.right, CASPAPackage.Literals::PREDICATE_OR__RIGHT)
	}
	
	@Check
	def checkType(PredicateAnd p){
		checkExpectedBoolean(p.left, CASPAPackage.Literals::PREDICATE_AND__LEFT)
		checkExpectedBoolean(p.right, CASPAPackage.Literals::PREDICATE_AND__RIGHT)
	}
	
	@Check
	def checkType(PredicateEquality p){
		checkExpectedInt(p.left, CASPAPackage.Literals::PREDICATE_EQUALITY__LEFT)
		checkExpectedInt(p.right, CASPAPackage.Literals::PREDICATE_EQUALITY__RIGHT)
	}
	
	@Check
	def checkType(PredicateComparison p){
		checkExpectedInt(p.left, CASPAPackage.Literals::PREDICATE_COMPARISON__LEFT)
		checkExpectedInt(p.right, CASPAPackage.Literals::PREDICATE_COMPARISON__RIGHT)
	}
	
	@Check
	def checkType(PredicateSub p){
		checkExpectedInt(p.left, CASPAPackage.Literals::PREDICATE_SUB__LEFT)
		checkExpectedInt(p.right, CASPAPackage.Literals::PREDICATE_SUB__RIGHT)
	}
	
	
	@Check
	def checkType(PredicatePlu p){
		checkExpectedInt(p.left, CASPAPackage.Literals::PREDICATE_PLU__LEFT)
		checkExpectedInt(p.right, CASPAPackage.Literals::PREDICATE_PLU__RIGHT)
	}
	
	
	@Check
	def checkType(PredicateMul p){
		checkExpectedInt(p.left, CASPAPackage.Literals::PREDICATE_MUL__LEFT)
		checkExpectedInt(p.right, CASPAPackage.Literals::PREDICATE_MUL__RIGHT)
	}	
	
	@Check
	def checkType(PredicateDiv p){
		checkExpectedInt(p.left, CASPAPackage.Literals::PREDICATE_DIV__LEFT)
		checkExpectedInt(p.right, CASPAPackage.Literals::PREDICATE_DIV__RIGHT)
	}	
	
	@Check
	def checkType(PredicateNot p){
		checkExpectedBoolean(p.expression, CASPAPackage.Literals::PREDICATE_NOT__EXPRESSION)
	}	
	
	
	def private checkExpectedBoolean(PredicateExpression exp, EReference reference) {
		checkExpectedType(exp, TypeProvider::boolConstantType, reference)
	}

	def private checkExpectedInt(PredicateExpression exp, EReference reference) {
		checkExpectedType(exp, TypeProvider::constantType, reference)
	}

	def private checkExpectedType(PredicateExpression exp,
			BaseType expectedType, EReference reference) {
				
		val actualType = getTypeAndCheckNotNull(exp, reference)
		if (actualType != expectedType)
			error("expected " + expectedType + " type, but was " + actualType,
					reference, WRONG_TYPE)
	}
	
	def private BaseType getTypeAndCheckNotNull(PredicateExpression exp,
			EReference reference) {
		var type = exp?.typeFor
		if (type == null)
			error("null type", reference, WRONG_TYPE)
		return type;
	}
	
	@Check
	def checkType(LocalSingleEventUpdate update){
		checkExpectedInt(update.assigner, CASPAPackage.Literals::LOCAL_SINGLE_EVENT_UPDATE__ASSIGNER)
	}
	

	@Check
	def checkType(UpdateSub p){
		checkExpectedInt(p.left, CASPAPackage.Literals::UPDATE_SUB__LEFT)
		checkExpectedInt(p.right, CASPAPackage.Literals::UPDATE_SUB__RIGHT)
	}
	
	
	@Check
	def checkType(UpdatePlu p){
		checkExpectedInt(p.left, CASPAPackage.Literals::UPDATE_PLU__LEFT)
		checkExpectedInt(p.right, CASPAPackage.Literals::UPDATE_PLU__RIGHT)
	}
	
	
	@Check
	def checkType(UpdateMul p){
		checkExpectedInt(p.left, CASPAPackage.Literals::UPDATE_MUL__LEFT)
		checkExpectedInt(p.right, CASPAPackage.Literals::UPDATE_MUL__RIGHT)
	}	
	
	@Check
	def checkType(UpdateDiv p){
		checkExpectedInt(p.left, CASPAPackage.Literals::UPDATE_DIV__LEFT)
		checkExpectedInt(p.right, CASPAPackage.Literals::UPDATE_DIV__RIGHT)
	}		

	def private checkExpectedInt(UpdateExpression exp, EReference reference) {
		checkExpectedType(exp, TypeProvider::constantType, reference)
	}

	def private checkExpectedType(UpdateExpression exp,
			BaseType expectedType, EReference reference) {
				
		val actualType = getTypeAndCheckNotNull(exp, reference)
		if (actualType != expectedType)
			error("expected " + expectedType + " type, but was " + actualType,
					reference, WRONG_TYPE)
	}
	
	def private BaseType getTypeAndCheckNotNull(UpdateExpression exp,
			EReference reference) {
		var type = exp?.typeFor
		if (type == null)
			error("null type", reference, WRONG_TYPE)
		return type;
	}
	
	@Check
	def checkFreeVariableNamesUnique(In in){
		
		var Set<String> freeVariableNames = new HashSet<String>()
		var Set<String> allParentTermsStoreNames = new HashSet<String>()
		var Set<String> temp = new HashSet<String>()
		
		for(expression : in.expressions)
			freeVariableNames.add((expression as FreeVariable).name)
		
		allParentTermsStoreNames = in.fromInGetProcess.fromProcessGetReferences.getParentTerms.storeNamesFromTerms
		
		for(name : allParentTermsStoreNames)
			temp.add(name)
		
		temp.removeAll(freeVariableNames)
		
		if(temp.size != allParentTermsStoreNames.size){
			error("Free variable names cannot be the same as local store names.",
			CASPAPackage::eINSTANCE.in_Expressions,
			FREE_VARIABLES_UNIQUE)
		}
	}
	
	@Check
	def checkSelfReferences(StoreExpression sr){
		
		var String result = ""
		
		switch(sr){
			PredicateStoreReference: sr.test
			OutStoreReference: println("osr " + sr)
			UpdateExpressionStoreReference: println("uesr " + sr)
			DistributionReference: println("dr " + sr)
			UniformReference: println("ur " + sr)
		}	
		
		if(result.length != 0)
			error(result,
			CASPAPackage::eINSTANCE.reference_Name,
			SELF_REFERENCE_HAS_REFERENCE)
	}
	
	def String test(PredicateStoreReference sr){
		if(!sr.allReferencesAreSeen)
			return "This reference does not refer to a declared store."
		else
			return ""
	}
	
	def boolean allReferencesAreSeen(PredicateStoreReference sr){
		(sr.ref as SelfReference).name.isInMap(sr.parentProcesses.parentTermsHash.storeNamesFromTermsHashMap)
	}
	
	//1) all store references are seen in parent Terms
	//	look up parent terms
	//	get parent term's store names
	//	check my name is in the list
	//2) all references are seen either in parent Term or () IFF action == input
		
}