/*
 * generated by Xtext
 */
package eu.quanticol.validation

import com.google.inject.Inject
import eu.quanticol.cASPA.CASPAPackage
import eu.quanticol.cASPA.LocalSingleEventUpdate
import eu.quanticol.cASPA.Model
import eu.quanticol.cASPA.Predicate
import eu.quanticol.cASPA.PredicateAnd
import eu.quanticol.cASPA.PredicateComparison
import eu.quanticol.cASPA.PredicateDiv
import eu.quanticol.cASPA.PredicateEquality
import eu.quanticol.cASPA.PredicateExpression
import eu.quanticol.cASPA.PredicateMul
import eu.quanticol.cASPA.PredicateNot
import eu.quanticol.cASPA.PredicateOr
import eu.quanticol.cASPA.PredicatePlu
import eu.quanticol.cASPA.PredicateSub
import eu.quanticol.cASPA.Process
import eu.quanticol.cASPA.UpdateDiv
import eu.quanticol.cASPA.UpdateExpression
import eu.quanticol.cASPA.UpdateMul
import eu.quanticol.cASPA.UpdatePlu
import eu.quanticol.cASPA.UpdateSub
import eu.quanticol.typing.BaseType
import eu.quanticol.typing.TypeProvider
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.validation.Check
import static extension org.eclipse.xtext.EcoreUtil2.*
import static org.eclipse.emf.ecore.util.EcoreUtil.*
import eu.quanticol.cASPA.In
import eu.quanticol.cASPA.FreeVariable
import eu.quanticol.ModelUtil
import java.util.Set
import java.util.HashSet
import eu.quanticol.cASPA.SelfReference
import eu.quanticol.cASPA.Action
import eu.quanticol.cASPA.Arguments
import eu.quanticol.cASPA.Out
import eu.quanticol.cASPA.DistributedEventUpdateProbability
import eu.quanticol.cASPA.DistributedEventUpdateUniform
import eu.quanticol.cASPA.Updates
import eu.quanticol.cASPA.StoreExpression
import eu.quanticol.cASPA.PredicateStoreReference
import eu.quanticol.cASPA.OutStoreReference
import eu.quanticol.cASPA.UpdateExpressionStoreReference
import eu.quanticol.cASPA.DistributionReference
import eu.quanticol.cASPA.UniformReference
import eu.quanticol.cASPA.ProcessExpression
import eu.quanticol.cASPA.Reference
import org.eclipse.emf.ecore.EObject
import eu.quanticol.cASPA.Store
import org.eclipse.emf.ecore.EAttribute
import eu.quanticol.cASPA.UpdateStoreReference

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class CASPAValidator extends AbstractCASPAValidator  {
	
	@Inject extension TypeProvider
	@Inject extension ModelUtil
	
	
	public static val PROCESS_NAMES_UNIQUE = "eu.quanticol.processNamesUnique"
	public static val WRONG_TYPE = "eu.quanticol.WrongType"
	public static val FREE_VARIABLES_UNIQUE = "eu.quanticol.freeVariablesUnique"
	public static val REFERENCE_HAS_NO_REFERENCE = "eu.quanticol.ReferenceHasNoReference"
	
	@Check
	def checkProcessNamesUnique(Process process){
		
		var processes = getContainerOfType(process, typeof(Model)).processes
		
		var count = 0
		
		for(proc : processes)
			if(proc.name.equals(process.name))
				count = count + 1
				
		if(count == 1)
			return
		else 
			error("Must have unique process names. '" + process.name + "' is repeated",
				CASPAPackage::eINSTANCE.process_Name,
				PROCESS_NAMES_UNIQUE
			)
			
	}
	
	@Check
	def checkType(Predicate predicate){
		checkExpectedBoolean(predicate.predicate, CASPAPackage.Literals::PREDICATE__PREDICATE)
	}
	
	@Check
	def checkType(PredicateOr p){
		checkExpectedBoolean(p.left, CASPAPackage.Literals::PREDICATE_OR__LEFT)
		checkExpectedBoolean(p.right, CASPAPackage.Literals::PREDICATE_OR__RIGHT)
	}
	
	@Check
	def checkType(PredicateAnd p){
		checkExpectedBoolean(p.left, CASPAPackage.Literals::PREDICATE_AND__LEFT)
		checkExpectedBoolean(p.right, CASPAPackage.Literals::PREDICATE_AND__RIGHT)
	}
	
	@Check
	def checkType(PredicateEquality p){
		checkExpectedInt(p.left, CASPAPackage.Literals::PREDICATE_EQUALITY__LEFT)
		checkExpectedInt(p.right, CASPAPackage.Literals::PREDICATE_EQUALITY__RIGHT)
	}
	
	@Check
	def checkType(PredicateComparison p){
		checkExpectedInt(p.left, CASPAPackage.Literals::PREDICATE_COMPARISON__LEFT)
		checkExpectedInt(p.right, CASPAPackage.Literals::PREDICATE_COMPARISON__RIGHT)
	}
	
	@Check
	def checkType(PredicateSub p){
		checkExpectedInt(p.left, CASPAPackage.Literals::PREDICATE_SUB__LEFT)
		checkExpectedInt(p.right, CASPAPackage.Literals::PREDICATE_SUB__RIGHT)
	}
	
	
	@Check
	def checkType(PredicatePlu p){
		checkExpectedInt(p.left, CASPAPackage.Literals::PREDICATE_PLU__LEFT)
		checkExpectedInt(p.right, CASPAPackage.Literals::PREDICATE_PLU__RIGHT)
	}
	
	
	@Check
	def checkType(PredicateMul p){
		checkExpectedInt(p.left, CASPAPackage.Literals::PREDICATE_MUL__LEFT)
		checkExpectedInt(p.right, CASPAPackage.Literals::PREDICATE_MUL__RIGHT)
	}	
	
	@Check
	def checkType(PredicateDiv p){
		checkExpectedInt(p.left, CASPAPackage.Literals::PREDICATE_DIV__LEFT)
		checkExpectedInt(p.right, CASPAPackage.Literals::PREDICATE_DIV__RIGHT)
	}	
	
	@Check
	def checkType(PredicateNot p){
		checkExpectedBoolean(p.expression, CASPAPackage.Literals::PREDICATE_NOT__EXPRESSION)
	}	
	
	
	def private checkExpectedBoolean(PredicateExpression exp, EReference reference) {
		checkExpectedType(exp, TypeProvider::boolConstantType, reference)
	}

	def private checkExpectedInt(PredicateExpression exp, EReference reference) {
		checkExpectedType(exp, TypeProvider::constantType, reference)
	}

	def private checkExpectedType(PredicateExpression exp,
			BaseType expectedType, EReference reference) {
				
		val actualType = getTypeAndCheckNotNull(exp, reference)
		if (actualType != expectedType)
			error("expected " + expectedType + " type, but was " + actualType,
					reference, WRONG_TYPE)
	}
	
	def private BaseType getTypeAndCheckNotNull(PredicateExpression exp,
			EReference reference) {
		var type = exp?.typeFor
		if (type == null)
			error("null type", reference, WRONG_TYPE)
		return type;
	}
	
	@Check
	def checkType(LocalSingleEventUpdate update){
		checkExpectedInt(update.assigner, CASPAPackage.Literals::LOCAL_SINGLE_EVENT_UPDATE__ASSIGNER)
	}
	

	@Check
	def checkType(UpdateSub p){
		checkExpectedInt(p.left, CASPAPackage.Literals::UPDATE_SUB__LEFT)
		checkExpectedInt(p.right, CASPAPackage.Literals::UPDATE_SUB__RIGHT)
	}
	
	
	@Check
	def checkType(UpdatePlu p){
		checkExpectedInt(p.left, CASPAPackage.Literals::UPDATE_PLU__LEFT)
		checkExpectedInt(p.right, CASPAPackage.Literals::UPDATE_PLU__RIGHT)
	}
	
	
	@Check
	def checkType(UpdateMul p){
		checkExpectedInt(p.left, CASPAPackage.Literals::UPDATE_MUL__LEFT)
		checkExpectedInt(p.right, CASPAPackage.Literals::UPDATE_MUL__RIGHT)
	}	
	
	@Check
	def checkType(UpdateDiv p){
		checkExpectedInt(p.left, CASPAPackage.Literals::UPDATE_DIV__LEFT)
		checkExpectedInt(p.right, CASPAPackage.Literals::UPDATE_DIV__RIGHT)
	}		

	def private checkExpectedInt(UpdateExpression exp, EReference reference) {
		checkExpectedType(exp, TypeProvider::constantType, reference)
	}

	def private checkExpectedType(UpdateExpression exp,
			BaseType expectedType, EReference reference) {
				
		val actualType = getTypeAndCheckNotNull(exp, reference)
		if (actualType != expectedType)
			error("expected " + expectedType + " type, but was " + actualType,
					reference, WRONG_TYPE)
	}
	
	def private BaseType getTypeAndCheckNotNull(UpdateExpression exp,
			EReference reference) {
		var type = exp?.typeFor
		if (type == null)
			error("null type", reference, WRONG_TYPE)
		return type;
	}
	
	@Check
	def checkFreeVariableNamesUnique(In in){
		
		var Set<String> freeVariableNames = new HashSet<String>()
		var Set<String> allParentTermsStoreNames = new HashSet<String>()
		var Set<String> temp = new HashSet<String>()
		
		for(expression : in.expressions)
			freeVariableNames.add((expression as FreeVariable).name)
		
		allParentTermsStoreNames = in.fromInGetProcess.fromProcessGetReferences.fromProcessesGetParentTerms.fromTermsGetStoreNames
		
		for(name : allParentTermsStoreNames)
			temp.add(name)
		
		temp.removeAll(freeVariableNames)
		
		if(temp.size != allParentTermsStoreNames.size){
			error("Free variable names cannot be the same as local store names.",
			CASPAPackage::eINSTANCE.in_Expressions,
			FREE_VARIABLES_UNIQUE)
		}
	}
	
	@Check
	def checkReference(StoreExpression se){
		
		var String result = se.getResult
		var String name = se.getName
		
//		println(se)
//		println("Reference '" + name + result)
		
		if(result.length > 1)
			error("Reference '" + name + result,
			se.getType,
			REFERENCE_HAS_NO_REFERENCE)
	}
	
	def String getResult(StoreExpression se){
		switch(se){
			Store: "'"
			SelfReference: "'"
			Reference: "'"
			PredicateStoreReference: se.check
			OutStoreReference: se.check
			UpdateStoreReference: se.check
			UpdateExpressionStoreReference: se.check
			DistributionReference: se.check
			UniformReference: se.check
		}
	}
	
	def EReference getType(StoreExpression se){
		switch(se){
			PredicateStoreReference: CASPAPackage::eINSTANCE.predicateStoreReference_Ref
			OutStoreReference: CASPAPackage::eINSTANCE.outStoreReference_Ref
			UpdateStoreReference: CASPAPackage::eINSTANCE.updateStoreReference_Ref
			UpdateExpressionStoreReference: CASPAPackage::eINSTANCE.updateExpressionStoreReference_Ref
			DistributionReference: CASPAPackage::eINSTANCE.distributionReference_Ref
			UniformReference: CASPAPackage::eINSTANCE.uniformReference_Ref
		}
	}
	
	def String getName(StoreExpression se){
		switch(se){
			Store: se.name
			Reference: se.name
			SelfReference: se.name
			PredicateStoreReference: se.ref.getName
			OutStoreReference: se.ref.getName
			UpdateStoreReference: se.ref.getName
			UpdateExpressionStoreReference: se.ref.getName
			DistributionReference: se.ref.getName
			UniformReference: se.ref.getName
		}
	}
	
	def String getStoreType(StoreExpression se){
		switch(se){
			Store: "sto"
			Reference: "ref"
			SelfReference: "sel"
			PredicateStoreReference: se.ref.getStoreType
			OutStoreReference: se.ref.getStoreType
			UpdateStoreReference: se.ref.getStoreType
			UpdateExpressionStoreReference: se.ref.getStoreType
			DistributionReference: se.ref.getStoreType
			UniformReference: se.ref.getStoreType
		}
	}
	
	def String check(PredicateStoreReference sr){
		
		if(!sr.ref.isReferenceSeenInTerms)
			return  "' does not refer to a declared store."
		return ""	
	}
	
	def String check(OutStoreReference sr){
		if(!sr.ref.referenceSeenInTerms)
			return "' does not refer to a declared store."
		return ""
	}
	
	def String check(UpdateStoreReference sr){
		if(!sr.ref.referenceSeenInTerms)
			return "' does not refer to a declared store."
		return ""
	}
		
	def boolean isReferenceSeenInTerms(StoreExpression sr){
		sr.getName.isInMap(sr.fromStoreExpressionGetProcesses.fromProcessesGetHashMapOfTerms.fromHashMapOfTermsGetStoreNames)
	}
	
	def String check(UpdateExpressionStoreReference sr){
		
		if(sr.getContainerOfType(ProcessExpression).getAllContentsOfType(In).length > 0){
			if(sr.getStoreType.equals("sel"))
				if(!sr.ref.referenceSeenInTerms)
					return "' does not refer to a declared store."
			//then we can have free variables
			if(!sr.ref.referenceSeenInTerms)
				if(!sr.ref.isReferenceSeenInInputArguments){
					return "' does not refer to a declared store or free variable."}
			return ""
		} else {
			//then we can't have free variables
			if(!sr.ref.referenceSeenInTerms)
				return "' does not refer to a declared store."
			return ""
		}
	}
	
	def String check(DistributionReference sr){
		if(!sr.ref.referenceSeenInTerms)
			if(sr.getStoreType.equals("sel"))
				if(!sr.ref.referenceSeenInTerms)
					return "' does not refer to a declared store."
			if(!sr.ref.isReferenceSeenInInputArguments)
				return "' does not refer to a declared store or free variable."
			return ""
	}
	
	def String check(UniformReference sr){
		if(!sr.ref.referenceSeenInTerms)
			if(sr.getStoreType.equals("sel"))
				if(!sr.ref.referenceSeenInTerms)
					return "' does not refer to a declared store."
			if(!sr.ref.isReferenceSeenInInputArguments)
				return "' does not refer to a declared store or free variable."
			return ""
	}
	
	def boolean isReferenceSeenInInputArguments(StoreExpression sr){
		sr.getName.isInList(sr.fromStoreExpressionGetProcessInArgs)
	}
	
	
}