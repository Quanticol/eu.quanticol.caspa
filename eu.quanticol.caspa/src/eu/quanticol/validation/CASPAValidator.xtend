/*
 * generated by Xtext
 */
package eu.quanticol.validation

import org.eclipse.xtext.validation.Check
import eu.quanticol.cASPA.ReferencedStore
import eu.quanticol.cASPA.CASPAPackage
import static extension eu.quanticol.typing.ModelUtil.*
import static extension org.eclipse.xtext.EcoreUtil2.*
import eu.quanticol.cASPA.Expression
import java.util.ArrayList
import eu.quanticol.cASPA.Or
import eu.quanticol.cASPA.And
import eu.quanticol.cASPA.Equality
import eu.quanticol.cASPA.Comparison
import eu.quanticol.cASPA.Sub
import eu.quanticol.cASPA.Plu
import eu.quanticol.cASPA.Mul
import eu.quanticol.cASPA.Div
import eu.quanticol.cASPA.Not
import eu.quanticol.cASPA.FreeVariable
import eu.quanticol.cASPA.Store
import eu.quanticol.cASPA.Model
import eu.quanticol.cASPA.Process
import com.google.inject.Inject
import eu.quanticol.typing.ETypeProvider
import eu.quanticol.cASPA.ActionNot
import eu.quanticol.cASPA.ActionOr
import eu.quanticol.cASPA.ActionAnd
import eu.quanticol.cASPA.ActionEquality
import eu.quanticol.cASPA.ActionComparison
import eu.quanticol.cASPA.ActionSub
import eu.quanticol.cASPA.ActionPlu
import eu.quanticol.cASPA.ActionMul
import eu.quanticol.cASPA.ActionDiv
import eu.quanticol.typing.ATypeProvider
import eu.quanticol.cASPA.LocalUpdateExpression
import eu.quanticol.cASPA.GlobalUpdateExpression
import eu.quanticol.cASPA.PredicateExpression
import eu.quanticol.cASPA.LocalEvaluationExpression
import eu.quanticol.cASPA.GlobalEvaluationExpression
import eu.quanticol.cASPA.FreeEvaluationExpression
import org.eclipse.emf.ecore.EReference
import eu.quanticol.cASPA.ActionExpression
import eu.quanticol.typing.ExpressionsType
import eu.quanticol.cASPA.LocalUpdateExpressionFunction
import eu.quanticol.cASPA.GlobalUpdateExpressionFunction

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class CASPAValidator extends AbstractCASPAValidator  {
	
	//STORE
	
	public static val SELF_REFERENCING_STORE = 'eu.quanticol.selfReferencingStore'
	
//	@Check
//	def void checkForwardReference(VariableRef varRef) {
//		val variable = varRef.getVariable()
//		if (variable != null && !varRef.variablesDefinedBefore.contains(
//				variable)) {
//			error("variable forward reference not allowed: '"
//					+ variable.name + "'",
//					ExpressionsPackage::eINSTANCE.variableRef_Variable,
//					FORWARD_REFERENCE, variable.name)
//		}
//	}
	
	@Check
	def checkNotSelfReferencing(ReferencedStore refStore){
			
		val store = refStore.value
		if(store != null && refStore.selfReferencedStores == store)
			error("Cannot have self referencing stores. '" + refStore.value.name + "' is seen in the expression",
				CASPAPackage::eINSTANCE.referencedStore_Value,
				eu.quanticol.validation.CASPAValidator.SELF_REFERENCING_STORE
			)
		
	}
	
	def void findReferencedRates(Expression e, ArrayList<String> strings) {
		switch (e) {
			Or: 				{e.left.findReferencedRates(strings) e.right.findReferencedRates(strings)}
			And: 				{e.left.findReferencedRates(strings) e.right.findReferencedRates(strings)}
			Equality:   		{e.left.findReferencedRates(strings) e.right.findReferencedRates(strings)}
			Comparison: 		{e.left.findReferencedRates(strings) e.right.findReferencedRates(strings)}
			Sub: 				{e.left.findReferencedRates(strings) e.right.findReferencedRates(strings)}
			Plu: 				{e.left.findReferencedRates(strings) e.right.findReferencedRates(strings)}
			Mul:				{e.left.findReferencedRates(strings) e.right.findReferencedRates(strings)}
			Div: 				{e.left.findReferencedRates(strings) e.right.findReferencedRates(strings)}
			Not: 				e.expression.findReferencedRates(strings)
			ReferencedStore: 	{strings.add(e.value.name)}
			FreeVariable:		{strings.add(e.value.substring(1))}
			}
	}
	
	public static val STORE_NAMES_UNIQUE = 'eu.quanticol.storeNamesUnique'
	
	@Check
	def checkStoresNamesUnique(Store store){
		
		var stores = getContainerOfType(store, typeof(Model)).stores
		
		var count = 0
		
		for(st : stores)
			if(st.name.contains(store.name))
				count = count + 1
				
		if(count == 1)
			return
		else 
			error("Must have unique store names. '" + store.name + "' is repeated",
				CASPAPackage::eINSTANCE.store_Name,
				STORE_NAMES_UNIQUE
			)
			
	}
	
	//PROCESS
	
	public static val PROCESS_NAMES_UNIQUE = 'eu.quanticol.processNamesUnique'
	
	@Check
	def checkensureProcessCycles(Process process){
		
		var processes = getContainerOfType(process, typeof(Model)).processes
		
		var count = 0
		
		for(proc : processes)
			if(proc.name.contains(process.name))
				count = count + 1
				
		if(count == 1)
			return
		else 
			error("Must have unique process names. '" + process.name + "' is repeated",
				CASPAPackage::eINSTANCE.process_Name,
				PROCESS_NAMES_UNIQUE
			)
			
	}
	
	@Inject extension ETypeProvider
	
	public static val WRONG_TYPE = "eu.quanticol.WrongType";
	
	@Check
	def checkType(Not not) {
		checkExpectedBoolean(not.expression,
				CASPAPackage$Literals::NOT__EXPRESSION)
	}
	
	@Check
	def checkType(ActionNot not) {
		checkExpectedBoolean(not.expression,
				CASPAPackage$Literals::ACTION_NOT__EXPRESSION)
	}
	
	@Check
	def checkType(Or or){
		checkExpectedBoolean(or.left,
			CASPAPackage$Literals::OR__LEFT
		)
		checkExpectedBoolean(or.right,
			CASPAPackage$Literals::OR__RIGHT
		)
	}
	
	@Check
	def checkType(ActionOr or){
		checkExpectedBoolean(or.left,
			CASPAPackage$Literals::ACTION_OR__LEFT
		)
		checkExpectedBoolean(or.right,
			CASPAPackage$Literals::ACTION_OR__RIGHT
		)
	}
	
	@Check
	def checkType(And and){
		checkExpectedBoolean(and.left,
			CASPAPackage$Literals::AND__LEFT
		)
		checkExpectedBoolean(and.right,
			CASPAPackage$Literals::AND__RIGHT
		)
	}
	
	@Check
	def checkType(ActionAnd and){
		checkExpectedBoolean(and.left,
			CASPAPackage$Literals::ACTION_AND__LEFT
		)
		checkExpectedBoolean(and.right,
			CASPAPackage$Literals::ACTION_AND__RIGHT
		)
	}
	
	@Check
	def checkType(Equality eq){
		checkExpectedBoolean(eq.left,
			CASPAPackage$Literals::EQUALITY__LEFT
		)
		checkExpectedBoolean(eq.right,
			CASPAPackage$Literals::EQUALITY__RIGHT
		)
	}
	
	@Check
	def checkType(ActionEquality eq){
		checkExpectedBoolean(eq.left,
			CASPAPackage$Literals::ACTION_EQUALITY__LEFT
		)
		checkExpectedBoolean(eq.right,
			CASPAPackage$Literals::ACTION_EQUALITY__RIGHT
		)
	}
	
	@Check
	def checkType(Comparison com){
		checkExpectedDouble(com.left,
			CASPAPackage$Literals::COMPARISON__LEFT
		)
		checkExpectedDouble(com.right,
			CASPAPackage$Literals::COMPARISON__RIGHT
		)
	}
	
	@Check
	def checkType(ActionComparison com){
		checkExpectedDouble(com.left,
			CASPAPackage$Literals::ACTION_COMPARISON__LEFT
		)
		checkExpectedDouble(com.right,
			CASPAPackage$Literals::ACTION_COMPARISON__RIGHT
		)
	}
	
	@Check
	def checkType(Sub sub){
		checkExpectedDouble(sub.left,
			CASPAPackage$Literals::SUB__LEFT
		)
		checkExpectedDouble(sub.right,
			CASPAPackage$Literals::SUB__RIGHT
		)
	}
	
	@Check
	def checkType(ActionSub sub){
		checkExpectedDouble(sub.left,
			CASPAPackage$Literals::ACTION_SUB__LEFT
		)
		checkExpectedDouble(sub.right,
			CASPAPackage$Literals::ACTION_SUB__RIGHT
		)
	}
	
	@Check
	def checkType(Plu plu){
		checkExpectedDouble(plu.left,
			CASPAPackage$Literals::PLU__LEFT
		)
		checkExpectedDouble(plu.right,
			CASPAPackage$Literals::PLU__RIGHT
		)
	}
	
	@Check
	def checkType(ActionPlu plu){
		checkExpectedDouble(plu.left,
			CASPAPackage$Literals::ACTION_PLU__LEFT
		)
		checkExpectedDouble(plu.right,
			CASPAPackage$Literals::ACTION_PLU__RIGHT
		)
	}
	
	@Check
	def checkType(Mul mul){
		checkExpectedDouble(mul.left,
			CASPAPackage$Literals::MUL__LEFT
		)
		checkExpectedDouble(mul.right,
			CASPAPackage$Literals::MUL__RIGHT
		)
	}
	
	@Check
	def checkType(ActionMul mul){
		checkExpectedDouble(mul.left,
			CASPAPackage$Literals::ACTION_MUL__LEFT
		)
		checkExpectedDouble(mul.right,
			CASPAPackage$Literals::ACTION_MUL__RIGHT
		)
	}
	
	@Check
	def checkType(Div div){
		checkExpectedDouble(div.left,
			CASPAPackage$Literals::DIV__LEFT
		)
		checkExpectedDouble(div.right,
			CASPAPackage$Literals::DIV__RIGHT
		)
	}
	
	@Check
	def checkType(ActionDiv div){
		checkExpectedDouble(div.left,
			CASPAPackage$Literals::ACTION_DIV__LEFT
		)
		checkExpectedDouble(div.right,
			CASPAPackage$Literals::ACTION_DIV__RIGHT
		)
	}
	
	
	@Inject extension ATypeProvider

	@Check
	def checkType(LocalUpdateExpression updateExpression){
		
		var type = updateExpression?.typeForA
		if(type == null)
			error("assignment has non matching type to reference", CASPAPackage$Literals::LOCAL_UPDATE_EXPRESSION__EXPRESSION, WRONG_TYPE)
		
	}
	
	@Check
	def checkType(GlobalUpdateExpression updateExpression){
		
		var type = updateExpression?.typeForA
		if(type == null)
			error("assignment has non matching type to reference", CASPAPackage$Literals::GLOBAL_UPDATE_EXPRESSION__EXPRESSION, WRONG_TYPE)
		
	}
	
	@Check
	def checkType(PredicateExpression predicateExpression){
		
		var type = predicateExpression?.typeForA
		if(type == null)
			error("Predicates must be boolean", CASPAPackage$Literals::PREDICATE_EXPRESSION__EXPRESSION, WRONG_TYPE)
		
	}
	
	@Check
	def checkType(LocalEvaluationExpression evalExpression){
		var type = evalExpression?.typeForA
		if(type == null)
			error("bad assignment, check types and references", 
				CASPAPackage$Literals::EVALUATION_EXPRESSION_IN__EXPRESSION, 
				WRONG_TYPE
			)
	}
	
	@Check
	def checkType(GlobalEvaluationExpression evalExpression){
		var type = evalExpression?.typeForA
		if(type == null)
			error("bad assignment, check types and references", CASPAPackage$Literals::EVALUATION_EXPRESSION_IN__EXPRESSION, WRONG_TYPE)
	}
	
	@Check
	def checkType(LocalUpdateExpressionFunction evalExpression){
		var type = evalExpression?.typeForA
		if(type == null)
			error("bad assignment, check types and references", 
				CASPAPackage$Literals::EVALUATION_EXPRESSION_IN__EXPRESSION, 
				WRONG_TYPE
			)
	}
	
	@Check
	def checkType(GlobalUpdateExpressionFunction evalExpression){
		var type = evalExpression?.typeForA
		if(type == null)
			error("bad assignment, check types and references", CASPAPackage$Literals::EVALUATION_EXPRESSION_IN__EXPRESSION, WRONG_TYPE)
	}
	
	@Check
	def checkType(FreeEvaluationExpression evalExpression){
		var type = evalExpression?.typeForA
		if(type == null)
			error("bad assignment, check types and references", CASPAPackage$Literals::FREE_EVALUATION_EXPRESSION__EXPRESSION, WRONG_TYPE)
	}
	
	
	def private checkExpectedBoolean(Expression exp, EReference reference) {
		checkExpectedType(exp, ETypeProvider::boolConstantType, reference)
	}
	
	def private checkExpectedBoolean(ActionExpression exp, EReference reference) {
		checkExpectedType(exp, ETypeProvider::boolConstantType, reference)
	}
	
	def private checkExpectedDouble(Expression exp, EReference reference) {
		checkExpectedType(exp, ETypeProvider::doubleConstantType, reference)
	}
	
	def private checkExpectedDouble(ActionExpression exp, EReference reference) {
		checkExpectedType(exp, ETypeProvider::doubleConstantType, reference)
	}
	
	def private checkExpectedType(ActionExpression exp,
			ExpressionsType expectedType, EReference reference) {
		val actualType = getTypeAndCheckNotNull(exp, reference)
		if (!(actualType == expectedType || actualType == ETypeProvider::freeVariableType))
			error("Expected " + expectedType + " type, but was " + actualType,
					reference, WRONG_TYPE)
	}
	
	def private checkExpectedType(Expression exp,
			ExpressionsType expectedType, EReference reference) {
		val actualType = getTypeAndCheckNotNull(exp, reference)
		if (actualType != expectedType)
			error("Expected " + expectedType + " type, but was " + actualType,
					reference, WRONG_TYPE)
	}
	
	def private ExpressionsType getTypeAndCheckNotNull(ActionExpression exp,
			EReference reference) {
		var type = exp?.typeFor
		if (type == null)
			error("null type", reference, WRONG_TYPE)
		return type;
	}
	
	def private ExpressionsType getTypeAndCheckNotNull(Expression exp,
			EReference reference) {
		var type = exp?.typeFor
		if (type == null)
			error("null type", reference, WRONG_TYPE)
		return type;
	}
	
//  public static val INVALID_NAME = 'invalidName'
//
//	@Check
//	def checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
//			warning('Name should start with a capital', 
//					MyDslPackage.Literals.GREETING__NAME,
//					INVALID_NAME)
//		}
//	}
}