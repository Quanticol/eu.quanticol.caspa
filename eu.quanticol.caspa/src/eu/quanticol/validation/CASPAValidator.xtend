/*
 * generated by Xtext
 */
package eu.quanticol.validation

import com.google.inject.Inject
import eu.quanticol.cASPA.CASPAPackage
import eu.quanticol.cASPA.LocalSingleEventUpdate
import eu.quanticol.cASPA.Model
import eu.quanticol.cASPA.Predicate
import eu.quanticol.cASPA.PredicateAnd
import eu.quanticol.cASPA.PredicateComparison
import eu.quanticol.cASPA.PredicateDiv
import eu.quanticol.cASPA.PredicateEquality
import eu.quanticol.cASPA.PredicateExpression
import eu.quanticol.cASPA.PredicateMul
import eu.quanticol.cASPA.PredicateNot
import eu.quanticol.cASPA.PredicateOr
import eu.quanticol.cASPA.PredicatePlu
import eu.quanticol.cASPA.PredicateSub
import eu.quanticol.cASPA.Process
import eu.quanticol.cASPA.UpdateDiv
import eu.quanticol.cASPA.UpdateExpression
import eu.quanticol.cASPA.UpdateMul
import eu.quanticol.cASPA.UpdatePlu
import eu.quanticol.cASPA.UpdateSub
import eu.quanticol.typing.BaseType
import eu.quanticol.typing.TypeProvider
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.validation.Check
import static org.eclipse.emf.ecore.util.EcoreUtil.*
import static extension org.eclipse.xtext.EcoreUtil2.*
import eu.quanticol.cASPA.In
import eu.quanticol.cASPA.FreeVariable
import eu.quanticol.ModelUtil
import java.util.Set
import java.util.HashSet
import eu.quanticol.cASPA.SelfReference
import eu.quanticol.cASPA.StoreExpression
import eu.quanticol.cASPA.PredicateStoreReference
import eu.quanticol.cASPA.OutStoreReference
import eu.quanticol.cASPA.UpdateExpressionStoreReference
import eu.quanticol.cASPA.DistributionReference
import eu.quanticol.cASPA.UniformReference
import eu.quanticol.cASPA.ProcessExpression
import eu.quanticol.cASPA.Reference
import eu.quanticol.cASPA.Store
import eu.quanticol.cASPA.UpdateStoreReference
import eu.quanticol.cASPA.Term
import eu.quanticol.cASPA.ReferencedProcess
import eu.quanticol.cASPA.Bool
import eu.quanticol.cASPA.Action
import eu.quanticol.cASPA.Unicast
import java.util.List
import java.util.ArrayList
import eu.quanticol.cASPA.Arguments
import eu.quanticol.cASPA.Out
import eu.quanticol.cASPA.Constant
import eu.quanticol.cASPA.Leaf

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class CASPAValidator extends AbstractCASPAValidator  {
	
	@Inject extension TypeProvider
	@Inject extension ModelUtil
	
	
	public static val PROCESS_NAMES_UNIQUE = "eu.quanticol.processNamesUnique"
	public static val WRONG_TYPE = "eu.quanticol.WrongType"
	public static val FREE_VARIABLES_UNIQUE = "eu.quanticol.freeVariablesUnique"
	public static val REFERENCE_HAS_NO_REFERENCE = "eu.quanticol.ReferenceHasNoReference"
	public static val NO_DUPLICATE_STORES_IN_TERMS = "eu.quanticol.noDuplicateStoresInTerms"
	public static val REQUIRE_UNIQUE_TERMS = "eu.quanticol.requireUniqueTerms"
	public static val STORE_NEVER_USED = "eu.quanticol.storeNeverUsed"
	public static val ARGUMENTS_MATCH = "eu.quanticol.argumentsMatch"
	public static val NO_ACTION_PARTNER = "eu.quanticol.noActionPartner"
	public static val PROCESS_NEVER_USED = "eu.quanticol.processNeverUsed"
	public static val PROCESSEXPRESSION_NOT_JUST_REFERENCES = "eu.quanticol.processExpressionsNotJustReferences"
	public static val PROCESS_IS_NIL_KILL = "eu.quanticol.processIsNilKill"
	
	@Check
	def checkProcessNamesUnique(Process process){
		
		var processes = getContainerOfType(process, typeof(Model)).processes
		
		var count = 0
		
		for(proc : processes)
			if(proc.name.equals(process.name))
				count = count + 1
				
		if(count == 1)
			return
		else 
			error("Must have unique process names. '" + process.name + "' is repeated",
				CASPAPackage::eINSTANCE.process_Name,
				PROCESS_NAMES_UNIQUE
			)
			
	}
	
	@Check
	def checkType(Predicate predicate){
		checkExpectedBoolean(predicate.predicate, CASPAPackage.Literals::PREDICATE__PREDICATE)
	}
	
	@Check
	def checkType(PredicateOr p){
		checkExpectedBoolean(p.left, CASPAPackage.Literals::PREDICATE_OR__LEFT)
		checkExpectedBoolean(p.right, CASPAPackage.Literals::PREDICATE_OR__RIGHT)
	}
	
	@Check
	def checkType(PredicateAnd p){
		checkExpectedBoolean(p.left, CASPAPackage.Literals::PREDICATE_AND__LEFT)
		checkExpectedBoolean(p.right, CASPAPackage.Literals::PREDICATE_AND__RIGHT)
	}
	
	@Check
	def checkType(PredicateEquality p){
		checkExpectedInt(p.left, CASPAPackage.Literals::PREDICATE_EQUALITY__LEFT)
		checkExpectedInt(p.right, CASPAPackage.Literals::PREDICATE_EQUALITY__RIGHT)
	}
	
	@Check
	def checkType(PredicateComparison p){
		checkExpectedInt(p.left, CASPAPackage.Literals::PREDICATE_COMPARISON__LEFT)
		checkExpectedInt(p.right, CASPAPackage.Literals::PREDICATE_COMPARISON__RIGHT)
	}
	
	@Check
	def checkType(PredicateSub p){
		checkExpectedInt(p.left, CASPAPackage.Literals::PREDICATE_SUB__LEFT)
		checkExpectedInt(p.right, CASPAPackage.Literals::PREDICATE_SUB__RIGHT)
	}
	
	
	@Check
	def checkType(PredicatePlu p){
		checkExpectedInt(p.left, CASPAPackage.Literals::PREDICATE_PLU__LEFT)
		checkExpectedInt(p.right, CASPAPackage.Literals::PREDICATE_PLU__RIGHT)
	}
	
	
	@Check
	def checkType(PredicateMul p){
		checkExpectedInt(p.left, CASPAPackage.Literals::PREDICATE_MUL__LEFT)
		checkExpectedInt(p.right, CASPAPackage.Literals::PREDICATE_MUL__RIGHT)
	}	
	
	@Check
	def checkType(PredicateDiv p){
		checkExpectedInt(p.left, CASPAPackage.Literals::PREDICATE_DIV__LEFT)
		checkExpectedInt(p.right, CASPAPackage.Literals::PREDICATE_DIV__RIGHT)
	}	
	
	@Check
	def checkType(PredicateNot p){
		checkExpectedBoolean(p.expression, CASPAPackage.Literals::PREDICATE_NOT__EXPRESSION)
	}	
	
	
	def private checkExpectedBoolean(PredicateExpression exp, EReference reference) {
		checkExpectedType(exp, TypeProvider::boolConstantType, reference)
	}

	def private checkExpectedInt(PredicateExpression exp, EReference reference) {
		checkExpectedType(exp, TypeProvider::constantType, reference)
	}

	def private checkExpectedType(PredicateExpression exp,
			BaseType expectedType, EReference reference) {
				
		val actualType = getTypeAndCheckNotNull(exp, reference)
		if (actualType != expectedType)
			error("expected " + expectedType + " type, but was " + actualType,
					reference, WRONG_TYPE)
	}
	
	def private BaseType getTypeAndCheckNotNull(PredicateExpression exp,
			EReference reference) {
		var type = exp?.typeFor
		if (type == null)
			error("null type", reference, WRONG_TYPE)
		return type;
	}
	
	@Check
	def checkType(LocalSingleEventUpdate update){
		checkExpectedInt(update.assigner, CASPAPackage.Literals::LOCAL_SINGLE_EVENT_UPDATE__ASSIGNER)
	}
	

	@Check
	def checkType(UpdateSub p){
		checkExpectedInt(p.left, CASPAPackage.Literals::UPDATE_SUB__LEFT)
		checkExpectedInt(p.right, CASPAPackage.Literals::UPDATE_SUB__RIGHT)
	}
	
	
	@Check
	def checkType(UpdatePlu p){
		checkExpectedInt(p.left, CASPAPackage.Literals::UPDATE_PLU__LEFT)
		checkExpectedInt(p.right, CASPAPackage.Literals::UPDATE_PLU__RIGHT)
	}
	
	
	@Check
	def checkType(UpdateMul p){
		checkExpectedInt(p.left, CASPAPackage.Literals::UPDATE_MUL__LEFT)
		checkExpectedInt(p.right, CASPAPackage.Literals::UPDATE_MUL__RIGHT)
	}	
	
	@Check
	def checkType(UpdateDiv p){
		checkExpectedInt(p.left, CASPAPackage.Literals::UPDATE_DIV__LEFT)
		checkExpectedInt(p.right, CASPAPackage.Literals::UPDATE_DIV__RIGHT)
	}		

	def private checkExpectedInt(UpdateExpression exp, EReference reference) {
		checkExpectedType(exp, TypeProvider::constantType, reference)
	}

	def private checkExpectedType(UpdateExpression exp,
			BaseType expectedType, EReference reference) {
				
		val actualType = getTypeAndCheckNotNull(exp, reference)
		if (actualType != expectedType)
			error("expected " + expectedType + " type, but was " + actualType,
					reference, WRONG_TYPE)
	}
	
	def private BaseType getTypeAndCheckNotNull(UpdateExpression exp,
			EReference reference) {
		var type = exp?.typeFor
		if (type == null)
			error("null type", reference, WRONG_TYPE)
		return type;
	}
	
	@Check
	def checkFreeVariableNamesUnique(In in){
		
		var Set<String> freeVariableNames = new HashSet<String>()
		var Set<String> allParentTermsStoreNames = new HashSet<String>()
		var Set<String> temp = new HashSet<String>()
		
		for(expression : in.expressions)
			freeVariableNames.add((expression as FreeVariable).name)
		
		allParentTermsStoreNames = in.fromInGetProcess.fromProcessGetReferences.fromProcessesGetParentTerms.fromTermsGetStoreNames
		
		for(name : allParentTermsStoreNames)
			temp.add(name)
		
		temp.removeAll(freeVariableNames)
		
		if(temp.size != allParentTermsStoreNames.size){
			error("Free variable names cannot be the same as local store names.",
			CASPAPackage::eINSTANCE.in_Expressions,
			FREE_VARIABLES_UNIQUE)
		}
	}
	
	@Check
	def checkReference(StoreExpression se){
		
		var String result = se.getResult
		var String name = se.getName
		
//		println(se)
//		println("Reference '" + name + result)
		
		if(result.length > 1)
			error("Reference '" + name + result,
			se.getType,
			REFERENCE_HAS_NO_REFERENCE)
	}
	
	def String getResult(StoreExpression se){
		switch(se){
			Store: "'"
			SelfReference: "'"
			Reference: "'"
			PredicateStoreReference: se.check
			OutStoreReference: se.check
			UpdateStoreReference: se.check
			UpdateExpressionStoreReference: se.check
			DistributionReference: se.check
			UniformReference: se.check
		}
	}
	
	def EReference getType(StoreExpression se){
		switch(se){
			PredicateStoreReference: CASPAPackage::eINSTANCE.predicateStoreReference_Ref
			OutStoreReference: CASPAPackage::eINSTANCE.outStoreReference_Ref
			UpdateStoreReference: CASPAPackage::eINSTANCE.updateStoreReference_Ref
			UpdateExpressionStoreReference: CASPAPackage::eINSTANCE.updateExpressionStoreReference_Ref
			DistributionReference: CASPAPackage::eINSTANCE.distributionReference_Ref
			UniformReference: CASPAPackage::eINSTANCE.uniformReference_Ref
		}
	}
	
	def String getName(StoreExpression se){
		switch(se){
			Store: se.name
			Reference: se.name
			SelfReference: se.name
			PredicateStoreReference: se.ref.getName
			OutStoreReference: se.ref.getName
			UpdateStoreReference: se.ref.getName
			UpdateExpressionStoreReference: se.ref.getName
			DistributionReference: se.ref.getName
			UniformReference: se.ref.getName
		}
	}
	
	def String getStoreType(StoreExpression se){
		switch(se){
			Store: "sto"
			Reference: "ref"
			SelfReference: "sel"
			PredicateStoreReference: se.ref.getStoreType
			OutStoreReference: se.ref.getStoreType
			UpdateStoreReference: se.ref.getStoreType
			UpdateExpressionStoreReference: se.ref.getStoreType
			DistributionReference: se.ref.getStoreType
			UniformReference: se.ref.getStoreType
		}
	}
	
	def String check(PredicateStoreReference sr){
		
		if(!sr.ref.isReferenceSeenInTerms)
			return  "' does not refer to a declared store."
		return ""	
	}
	
	def String check(OutStoreReference sr){
		if(!sr.ref.referenceSeenInTerms)
			return "' does not refer to a declared store."
		return ""
	}
	
	def String check(UpdateStoreReference sr){
		if(!sr.ref.referenceSeenInTerms)
			return "' does not refer to a declared store."
		return ""
	}
		
	def boolean isReferenceSeenInTerms(StoreExpression sr){
		sr.getName.isInMap(sr.fromStoreExpressionGetProcesses.fromProcessesGetHashMapOfTerms.fromHashMapOfTermsGetStoreNames)
	}
	
	def String check(UpdateExpressionStoreReference sr){
		
		if(sr.getContainerOfType(ProcessExpression).getAllContentsOfType(In).length > 0){
			if(sr.getStoreType.equals("sel"))
				if(!sr.ref.referenceSeenInTerms)
					return "' does not refer to a declared store."
			//then we can have free variables
			if(!sr.ref.referenceSeenInTerms)
				if(!sr.ref.isReferenceSeenInInputArguments){
					return "' does not refer to a declared store or free variable."}
			return ""
		} else {
			//then we can't have free variables
			if(!sr.ref.referenceSeenInTerms)
				return "' does not refer to a declared store."
			return ""
		}
	}
	
	def String check(DistributionReference sr){
		if(!sr.ref.referenceSeenInTerms)
			if(sr.getStoreType.equals("sel"))
				if(!sr.ref.referenceSeenInTerms)
					return "' does not refer to a declared store."
			if(!sr.ref.isReferenceSeenInInputArguments)
				return "' does not refer to a declared store or free variable."
			return ""
	}
	
	def String check(UniformReference sr){
		if(!sr.ref.referenceSeenInTerms)
			if(sr.getStoreType.equals("sel"))
				if(!sr.ref.referenceSeenInTerms)
					return "' does not refer to a declared store."
			if(!sr.ref.isReferenceSeenInInputArguments)
				return "' does not refer to a declared store or free variable."
			return ""
	}
	
	def boolean isReferenceSeenInInputArguments(StoreExpression sr){
		sr.getName.isInList(sr.fromStoreExpressionGetProcessInArgs)
	}
	
	@Check
	def checkNoDuplicateStoresInTerms(Store store){
		
		var int count = 0
		for(st : store.getContainerOfType(Term).stores.stores)
			if(store.name.equals((st as Store).name))
				count++
		
		if(count > 1){
			error("Store names cannot be repeated in Terms.",
			CASPAPackage::eINSTANCE.store_Name,
			NO_DUPLICATE_STORES_IN_TERMS)
		}
		
	}
	
	@Check
	def checkUniqueTerms(Term term){
		
		var terms = term.getContainerOfType(Model).terms
		var name = ((term.ref as ReferencedProcess).ref as Process).name
		var Set<String> myStoreNames = new HashSet<String>()
		var int count = 0;
		
		for(s : term.stores.stores)
			myStoreNames.add((s as Store).name + (s as Store).value)
			
		for(t : terms){
			
			var String tName = ((t.ref as ReferencedProcess).ref as Process).name
			var Set<String> temp = new HashSet<String>()
			for(s : t.stores.stores)
				temp.add((s as Store).name + (s as Store).value)
				
			if(myStoreNames.equals(temp) && name.equals(tName)){
				count++
			}
		}
		
		if(count > 1){
			error("Terms must be unique.",
			CASPAPackage::Literals.TERM__STORES,
			REQUIRE_UNIQUE_TERMS)
		}
		
	}
	
	@Check
	def checkStoresAreUsed(Store store){
		
		var processes = store.getContainerOfType(Model).processes
		var name = store.name
		var boolean exists = false
		
		for(process : processes){
			for(sr : process.getAllContentsOfType(SelfReference))
				if(sr.name.equals(name))
					exists = true
			for(r : process.getAllContentsOfType(Reference))
				if(r.name.equals(name))
					exists = true
		}
		
		
		if(!exists){
			warning("Store never used locally.",
			CASPAPackage::Literals.STORE__NAME,
			STORE_NEVER_USED)
		}
		
	}
	
	@Check
	def checkArgumentsMatch(Unicast action){
		
		var boolean fails = true
		var processes = action.getContainerOfType(Model).processes
		var String name = action.name
		var String inputOutput = action.arguments.inputOrOutputArgument
		var int args = 0
		var int count = 0
		
		if(action.arguments.inputOrOutputArgument.equals("In"))
			args = action.arguments.getAllContentsOfType(FreeVariable).size
		else {
			args = action.arguments.getAllContentsOfType(Constant).size
			args = args + action.arguments.getAllContentsOfType(Reference).size
			args = args + action.arguments.getAllContentsOfType(SelfReference).size
			}
			
		for(p : processes)
			for(u : p.getAllContentsOfType(Unicast)){
				
				if(!u.arguments.inputOrOutputArgument.equals(inputOutput)){
					
					var int temp = 0
					
					if(u.arguments.inputOrOutputArgument.equals("In")){
						temp = u.arguments.getAllContentsOfType(FreeVariable).size
					}else{
						temp = u.arguments.getAllContentsOfType(Constant).size
						temp = temp + u.arguments.getAllContentsOfType(Reference).size
						temp = temp + u.arguments.getAllContentsOfType(SelfReference).size
					}
					
					if(u.name.equals(name) && temp == args){
						count++
					}
				}
			 }
		fails = count == 0
		if(fails){
			error("No partner action with matching number of arguments.",
			CASPAPackage::Literals.ACTION__NAME,
			ARGUMENTS_MATCH)
		}
		
	}
	
	@Check
	def checkActionHasPartner(Unicast action){
		
		var boolean fails = true
		
		var processes = action.getContainerOfType(Model).processes
		var String name = action.name
		var String inputOutput = action.arguments.inputOrOutputArgument
		var int count = 0
		
		for(p : processes)
			for(u : p.getAllContentsOfType(Unicast)){
				if(!u.arguments.inputOrOutputArgument.equals(inputOutput)){
					if(u.name.equals(name)){
						count++
					}
				}
			 }
		fails = count == 0
			 
		if(fails){
			warning("No receiving or sending partner action.",
			CASPAPackage::Literals.ACTION__NAME,
			NO_ACTION_PARTNER)
		}
		
	}
	
	def String inputOrOutputArgument(Arguments arg){
		switch(arg){
			In: 	"In"
			Out:	"Out"	
		}
		
	}
	
	@Check
	def checkProcessIsUsed(Process process){
		
		var boolean fails = true
		
		var terms = process.getContainerOfType(Model).terms
		var ArrayList<String> referencedProcesses = new ArrayList<String>()
		
		var allProcesses = process.fromProcessGetReferences
		
		for(term : terms)
			for( rp : term.getAllContentsOfType(ReferencedProcess))
				referencedProcesses.add(rp.ref.name)
			
		fails = !referencedProcesses.contains(process.name) && (allProcesses.size == 1)
		
		if(fails){
			warning("Process '"+process.name+"' is never used.",
			CASPAPackage::Literals.PROCESS__NAME,
			PROCESS_NEVER_USED)
		}
		
	}
	
	@Check
	def checkProcessExpressionsAreMoreThanJustReferences(Process p){
		
//		println("----------------------Proc: " + p)
		
		var boolean fail = false;
		var allProcesses = p.fromProcessGetReferences
		fail = testPathChoParRef(allProcesses,p)
		
		if(fail){
			error("Process '"+p.name+"' has looping process references: Expression '" + p.value.cTString + "'.",
			CASPAPackage::Literals.PROCESS__VALUE,
			PROCESSEXPRESSION_NOT_JUST_REFERENCES)
		}
		
//		println("result: " + fail)
	}
	
	def boolean testPathChoParRef(Set<Process> set, Process start){
		
//		println("proc@test: " + start.name)
		
		var Set<Process> mySet = new HashSet<Process>(set)
		//mySet.remove(start)
		
		//get this processes referenced processes, but only if they are in the incoming set
		var refs = mySet.getReference(start)
		
		//remove the references from the set
		mySet.removeRefFromSet(refs)
		
		//is this Process par, cho or ref
		var boolean parChoRef = start.fromProcessGetIfParChoRef
		
		if(refs.size > 0){
			
			var ArrayList<Boolean> test = new ArrayList<Boolean>();
			
			for(var i = 0; i < refs.size; i++){
//				println(refs.get(i).name)
//				println(mySet)
				test.add(testPathChoParRef(mySet,refs.get(i)))
				
				
			}
			
			if(test.contains(true))
				parChoRef = true && parChoRef
			else
				parChoRef = false
		}
		
		//println(start.name + ": " + parChoRef)
		return parChoRef
		
	}
	
	def ArrayList<Process> getReference(Set<Process> s, Process p){
		
//		println("incoming set: " + s)
		
		var refProcs = p.getAllContentsOfType(ReferencedProcess)
		var ArrayList<Process> procs = new ArrayList<Process>()
		
		for(refProc : refProcs){
			if(s.contains(refProc.ref as Process))
				procs.add(refProc.ref as Process)
		}
//		println("refs: " + procs)
		
		return procs
	}
	
	def void removeRefFromSet(Set<Process> s, ArrayList<Process> l){
		
		for(proc : l)
			s.remove(proc)
			
	}
	
	@Check
	def checkNil(Process p){
		var boolean fails = p.fromProcessGetIfNilKill
		if(fails){
			warning("Process '"+p.name+"' is only '" + (p.value as Leaf).value + "'.",
			CASPAPackage::Literals.PROCESS__VALUE,
			PROCESS_IS_NIL_KILL)
		}
	}
	
	
}