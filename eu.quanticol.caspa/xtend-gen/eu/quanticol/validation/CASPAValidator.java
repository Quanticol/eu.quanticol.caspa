/**
 * generated by Xtext
 */
package eu.quanticol.validation;

import com.google.common.base.Objects;
import com.google.inject.Inject;
import eu.quanticol.ModelUtil;
import eu.quanticol.cASPA.Arguments;
import eu.quanticol.cASPA.CASPAPackage;
import eu.quanticol.cASPA.DistributionReference;
import eu.quanticol.cASPA.FreeVariable;
import eu.quanticol.cASPA.In;
import eu.quanticol.cASPA.LocalSingleEventUpdate;
import eu.quanticol.cASPA.Model;
import eu.quanticol.cASPA.OutStoreReference;
import eu.quanticol.cASPA.Predicate;
import eu.quanticol.cASPA.PredicateAnd;
import eu.quanticol.cASPA.PredicateComparison;
import eu.quanticol.cASPA.PredicateDiv;
import eu.quanticol.cASPA.PredicateEquality;
import eu.quanticol.cASPA.PredicateExpression;
import eu.quanticol.cASPA.PredicateMul;
import eu.quanticol.cASPA.PredicateNot;
import eu.quanticol.cASPA.PredicateOr;
import eu.quanticol.cASPA.PredicatePlu;
import eu.quanticol.cASPA.PredicateStoreReference;
import eu.quanticol.cASPA.PredicateSub;
import eu.quanticol.cASPA.ProcessExpression;
import eu.quanticol.cASPA.Reference;
import eu.quanticol.cASPA.SelfReference;
import eu.quanticol.cASPA.Store;
import eu.quanticol.cASPA.StoreExpression;
import eu.quanticol.cASPA.Term;
import eu.quanticol.cASPA.UniformReference;
import eu.quanticol.cASPA.UpdateDiv;
import eu.quanticol.cASPA.UpdateExpression;
import eu.quanticol.cASPA.UpdateExpressionStoreReference;
import eu.quanticol.cASPA.UpdateMul;
import eu.quanticol.cASPA.UpdatePlu;
import eu.quanticol.cASPA.UpdateStoreReference;
import eu.quanticol.cASPA.UpdateSub;
import eu.quanticol.typing.BaseType;
import eu.quanticol.typing.TypeProvider;
import eu.quanticol.validation.AbstractCASPAValidator;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EAttribute;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Extension;

/**
 * Custom validation rules.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
@SuppressWarnings("all")
public class CASPAValidator extends AbstractCASPAValidator {
  @Inject
  @Extension
  private TypeProvider _typeProvider;
  
  @Inject
  @Extension
  private ModelUtil _modelUtil;
  
  public final static String PROCESS_NAMES_UNIQUE = "eu.quanticol.processNamesUnique";
  
  public final static String WRONG_TYPE = "eu.quanticol.WrongType";
  
  public final static String FREE_VARIABLES_UNIQUE = "eu.quanticol.freeVariablesUnique";
  
  public final static String REFERENCE_HAS_NO_REFERENCE = "eu.quanticol.ReferenceHasNoReference";
  
  @Check
  public void checkProcessNamesUnique(final eu.quanticol.cASPA.Process process) {
    Model _containerOfType = EcoreUtil2.<Model>getContainerOfType(process, Model.class);
    EList<eu.quanticol.cASPA.Process> processes = _containerOfType.getProcesses();
    int count = 0;
    for (final eu.quanticol.cASPA.Process proc : processes) {
      String _name = proc.getName();
      String _name_1 = process.getName();
      boolean _equals = _name.equals(_name_1);
      if (_equals) {
        count = (count + 1);
      }
    }
    if ((count == 1)) {
      return;
    } else {
      String _name_2 = process.getName();
      String _plus = ("Must have unique process names. \'" + _name_2);
      String _plus_1 = (_plus + "\' is repeated");
      EAttribute _process_Name = CASPAPackage.eINSTANCE.getProcess_Name();
      this.error(_plus_1, _process_Name, 
        CASPAValidator.PROCESS_NAMES_UNIQUE);
    }
  }
  
  @Check
  public void checkType(final Predicate predicate) {
    PredicateExpression _predicate = predicate.getPredicate();
    this.checkExpectedBoolean(_predicate, CASPAPackage.Literals.PREDICATE__PREDICATE);
  }
  
  @Check
  public void checkType(final PredicateOr p) {
    PredicateExpression _left = p.getLeft();
    this.checkExpectedBoolean(_left, CASPAPackage.Literals.PREDICATE_OR__LEFT);
    PredicateExpression _right = p.getRight();
    this.checkExpectedBoolean(_right, CASPAPackage.Literals.PREDICATE_OR__RIGHT);
  }
  
  @Check
  public void checkType(final PredicateAnd p) {
    PredicateExpression _left = p.getLeft();
    this.checkExpectedBoolean(_left, CASPAPackage.Literals.PREDICATE_AND__LEFT);
    PredicateExpression _right = p.getRight();
    this.checkExpectedBoolean(_right, CASPAPackage.Literals.PREDICATE_AND__RIGHT);
  }
  
  @Check
  public void checkType(final PredicateEquality p) {
    PredicateExpression _left = p.getLeft();
    this.checkExpectedInt(_left, CASPAPackage.Literals.PREDICATE_EQUALITY__LEFT);
    PredicateExpression _right = p.getRight();
    this.checkExpectedInt(_right, CASPAPackage.Literals.PREDICATE_EQUALITY__RIGHT);
  }
  
  @Check
  public void checkType(final PredicateComparison p) {
    PredicateExpression _left = p.getLeft();
    this.checkExpectedInt(_left, CASPAPackage.Literals.PREDICATE_COMPARISON__LEFT);
    PredicateExpression _right = p.getRight();
    this.checkExpectedInt(_right, CASPAPackage.Literals.PREDICATE_COMPARISON__RIGHT);
  }
  
  @Check
  public void checkType(final PredicateSub p) {
    PredicateExpression _left = p.getLeft();
    this.checkExpectedInt(_left, CASPAPackage.Literals.PREDICATE_SUB__LEFT);
    PredicateExpression _right = p.getRight();
    this.checkExpectedInt(_right, CASPAPackage.Literals.PREDICATE_SUB__RIGHT);
  }
  
  @Check
  public void checkType(final PredicatePlu p) {
    PredicateExpression _left = p.getLeft();
    this.checkExpectedInt(_left, CASPAPackage.Literals.PREDICATE_PLU__LEFT);
    PredicateExpression _right = p.getRight();
    this.checkExpectedInt(_right, CASPAPackage.Literals.PREDICATE_PLU__RIGHT);
  }
  
  @Check
  public void checkType(final PredicateMul p) {
    PredicateExpression _left = p.getLeft();
    this.checkExpectedInt(_left, CASPAPackage.Literals.PREDICATE_MUL__LEFT);
    PredicateExpression _right = p.getRight();
    this.checkExpectedInt(_right, CASPAPackage.Literals.PREDICATE_MUL__RIGHT);
  }
  
  @Check
  public void checkType(final PredicateDiv p) {
    PredicateExpression _left = p.getLeft();
    this.checkExpectedInt(_left, CASPAPackage.Literals.PREDICATE_DIV__LEFT);
    PredicateExpression _right = p.getRight();
    this.checkExpectedInt(_right, CASPAPackage.Literals.PREDICATE_DIV__RIGHT);
  }
  
  @Check
  public void checkType(final PredicateNot p) {
    PredicateExpression _expression = p.getExpression();
    this.checkExpectedBoolean(_expression, CASPAPackage.Literals.PREDICATE_NOT__EXPRESSION);
  }
  
  private void checkExpectedBoolean(final PredicateExpression exp, final EReference reference) {
    this.checkExpectedType(exp, TypeProvider.boolConstantType, reference);
  }
  
  private void checkExpectedInt(final PredicateExpression exp, final EReference reference) {
    this.checkExpectedType(exp, TypeProvider.constantType, reference);
  }
  
  private void checkExpectedType(final PredicateExpression exp, final BaseType expectedType, final EReference reference) {
    final BaseType actualType = this.getTypeAndCheckNotNull(exp, reference);
    boolean _notEquals = (!Objects.equal(actualType, expectedType));
    if (_notEquals) {
      this.error(((("expected " + expectedType) + " type, but was ") + actualType), reference, CASPAValidator.WRONG_TYPE);
    }
  }
  
  private BaseType getTypeAndCheckNotNull(final PredicateExpression exp, final EReference reference) {
    BaseType _typeFor = null;
    if (exp!=null) {
      _typeFor=this._typeProvider.typeFor(exp);
    }
    BaseType type = _typeFor;
    boolean _equals = Objects.equal(type, null);
    if (_equals) {
      this.error("null type", reference, CASPAValidator.WRONG_TYPE);
    }
    return type;
  }
  
  @Check
  public void checkType(final LocalSingleEventUpdate update) {
    UpdateExpression _assigner = update.getAssigner();
    this.checkExpectedInt(_assigner, CASPAPackage.Literals.LOCAL_SINGLE_EVENT_UPDATE__ASSIGNER);
  }
  
  @Check
  public void checkType(final UpdateSub p) {
    UpdateExpression _left = p.getLeft();
    this.checkExpectedInt(_left, CASPAPackage.Literals.UPDATE_SUB__LEFT);
    UpdateExpression _right = p.getRight();
    this.checkExpectedInt(_right, CASPAPackage.Literals.UPDATE_SUB__RIGHT);
  }
  
  @Check
  public void checkType(final UpdatePlu p) {
    UpdateExpression _left = p.getLeft();
    this.checkExpectedInt(_left, CASPAPackage.Literals.UPDATE_PLU__LEFT);
    UpdateExpression _right = p.getRight();
    this.checkExpectedInt(_right, CASPAPackage.Literals.UPDATE_PLU__RIGHT);
  }
  
  @Check
  public void checkType(final UpdateMul p) {
    UpdateExpression _left = p.getLeft();
    this.checkExpectedInt(_left, CASPAPackage.Literals.UPDATE_MUL__LEFT);
    UpdateExpression _right = p.getRight();
    this.checkExpectedInt(_right, CASPAPackage.Literals.UPDATE_MUL__RIGHT);
  }
  
  @Check
  public void checkType(final UpdateDiv p) {
    UpdateExpression _left = p.getLeft();
    this.checkExpectedInt(_left, CASPAPackage.Literals.UPDATE_DIV__LEFT);
    UpdateExpression _right = p.getRight();
    this.checkExpectedInt(_right, CASPAPackage.Literals.UPDATE_DIV__RIGHT);
  }
  
  private void checkExpectedInt(final UpdateExpression exp, final EReference reference) {
    this.checkExpectedType(exp, TypeProvider.constantType, reference);
  }
  
  private void checkExpectedType(final UpdateExpression exp, final BaseType expectedType, final EReference reference) {
    final BaseType actualType = this.getTypeAndCheckNotNull(exp, reference);
    boolean _notEquals = (!Objects.equal(actualType, expectedType));
    if (_notEquals) {
      this.error(((("expected " + expectedType) + " type, but was ") + actualType), reference, CASPAValidator.WRONG_TYPE);
    }
  }
  
  private BaseType getTypeAndCheckNotNull(final UpdateExpression exp, final EReference reference) {
    BaseType _typeFor = null;
    if (exp!=null) {
      _typeFor=this._typeProvider.typeFor(exp);
    }
    BaseType type = _typeFor;
    boolean _equals = Objects.equal(type, null);
    if (_equals) {
      this.error("null type", reference, CASPAValidator.WRONG_TYPE);
    }
    return type;
  }
  
  @Check
  public void checkFreeVariableNamesUnique(final In in) {
    Set<String> freeVariableNames = new HashSet<String>();
    Set<String> allParentTermsStoreNames = new HashSet<String>();
    Set<String> temp = new HashSet<String>();
    EList<Arguments> _expressions = in.getExpressions();
    for (final Arguments expression : _expressions) {
      String _name = ((FreeVariable) expression).getName();
      freeVariableNames.add(_name);
    }
    eu.quanticol.cASPA.Process _fromInGetProcess = this._modelUtil.fromInGetProcess(in);
    Set<eu.quanticol.cASPA.Process> _fromProcessGetReferences = this._modelUtil.fromProcessGetReferences(_fromInGetProcess);
    Set<Term> _fromProcessesGetParentTerms = this._modelUtil.fromProcessesGetParentTerms(_fromProcessGetReferences);
    Set<String> _fromTermsGetStoreNames = this._modelUtil.fromTermsGetStoreNames(_fromProcessesGetParentTerms);
    allParentTermsStoreNames = _fromTermsGetStoreNames;
    for (final String name : allParentTermsStoreNames) {
      temp.add(name);
    }
    temp.removeAll(freeVariableNames);
    int _size = temp.size();
    int _size_1 = allParentTermsStoreNames.size();
    boolean _notEquals = (_size != _size_1);
    if (_notEquals) {
      EReference _in_Expressions = CASPAPackage.eINSTANCE.getIn_Expressions();
      this.error("Free variable names cannot be the same as local store names.", _in_Expressions, 
        CASPAValidator.FREE_VARIABLES_UNIQUE);
    }
  }
  
  @Check
  public void checkReference(final StoreExpression se) {
    String result = this.getResult(se);
    String name = this.getName(se);
    int _length = result.length();
    boolean _greaterThan = (_length > 1);
    if (_greaterThan) {
      EReference _type = this.getType(se);
      this.error((("Reference \'" + name) + result), _type, 
        CASPAValidator.REFERENCE_HAS_NO_REFERENCE);
    }
  }
  
  public String getResult(final StoreExpression se) {
    String _switchResult = null;
    boolean _matched = false;
    if (!_matched) {
      if (se instanceof Store) {
        _matched=true;
        _switchResult = "\'";
      }
    }
    if (!_matched) {
      if (se instanceof SelfReference) {
        _matched=true;
        _switchResult = "\'";
      }
    }
    if (!_matched) {
      if (se instanceof Reference) {
        _matched=true;
        _switchResult = "\'";
      }
    }
    if (!_matched) {
      if (se instanceof PredicateStoreReference) {
        _matched=true;
        _switchResult = this.check(((PredicateStoreReference)se));
      }
    }
    if (!_matched) {
      if (se instanceof OutStoreReference) {
        _matched=true;
        _switchResult = this.check(((OutStoreReference)se));
      }
    }
    if (!_matched) {
      if (se instanceof UpdateStoreReference) {
        _matched=true;
        _switchResult = this.check(((UpdateStoreReference)se));
      }
    }
    if (!_matched) {
      if (se instanceof UpdateExpressionStoreReference) {
        _matched=true;
        _switchResult = this.check(((UpdateExpressionStoreReference)se));
      }
    }
    if (!_matched) {
      if (se instanceof DistributionReference) {
        _matched=true;
        _switchResult = this.check(((DistributionReference)se));
      }
    }
    if (!_matched) {
      if (se instanceof UniformReference) {
        _matched=true;
        _switchResult = this.check(((UniformReference)se));
      }
    }
    return _switchResult;
  }
  
  public EReference getType(final StoreExpression se) {
    EReference _switchResult = null;
    boolean _matched = false;
    if (!_matched) {
      if (se instanceof PredicateStoreReference) {
        _matched=true;
        _switchResult = CASPAPackage.eINSTANCE.getPredicateStoreReference_Ref();
      }
    }
    if (!_matched) {
      if (se instanceof OutStoreReference) {
        _matched=true;
        _switchResult = CASPAPackage.eINSTANCE.getOutStoreReference_Ref();
      }
    }
    if (!_matched) {
      if (se instanceof UpdateStoreReference) {
        _matched=true;
        _switchResult = CASPAPackage.eINSTANCE.getUpdateStoreReference_Ref();
      }
    }
    if (!_matched) {
      if (se instanceof UpdateExpressionStoreReference) {
        _matched=true;
        _switchResult = CASPAPackage.eINSTANCE.getUpdateExpressionStoreReference_Ref();
      }
    }
    if (!_matched) {
      if (se instanceof DistributionReference) {
        _matched=true;
        _switchResult = CASPAPackage.eINSTANCE.getDistributionReference_Ref();
      }
    }
    if (!_matched) {
      if (se instanceof UniformReference) {
        _matched=true;
        _switchResult = CASPAPackage.eINSTANCE.getUniformReference_Ref();
      }
    }
    return _switchResult;
  }
  
  public String getName(final StoreExpression se) {
    String _switchResult = null;
    boolean _matched = false;
    if (!_matched) {
      if (se instanceof Store) {
        _matched=true;
        _switchResult = ((Store)se).getName();
      }
    }
    if (!_matched) {
      if (se instanceof Reference) {
        _matched=true;
        _switchResult = ((Reference)se).getName();
      }
    }
    if (!_matched) {
      if (se instanceof SelfReference) {
        _matched=true;
        _switchResult = ((SelfReference)se).getName();
      }
    }
    if (!_matched) {
      if (se instanceof PredicateStoreReference) {
        _matched=true;
        StoreExpression _ref = ((PredicateStoreReference)se).getRef();
        _switchResult = this.getName(_ref);
      }
    }
    if (!_matched) {
      if (se instanceof OutStoreReference) {
        _matched=true;
        StoreExpression _ref = ((OutStoreReference)se).getRef();
        _switchResult = this.getName(_ref);
      }
    }
    if (!_matched) {
      if (se instanceof UpdateStoreReference) {
        _matched=true;
        StoreExpression _ref = ((UpdateStoreReference)se).getRef();
        _switchResult = this.getName(_ref);
      }
    }
    if (!_matched) {
      if (se instanceof UpdateExpressionStoreReference) {
        _matched=true;
        StoreExpression _ref = ((UpdateExpressionStoreReference)se).getRef();
        _switchResult = this.getName(_ref);
      }
    }
    if (!_matched) {
      if (se instanceof DistributionReference) {
        _matched=true;
        StoreExpression _ref = ((DistributionReference)se).getRef();
        _switchResult = this.getName(_ref);
      }
    }
    if (!_matched) {
      if (se instanceof UniformReference) {
        _matched=true;
        StoreExpression _ref = ((UniformReference)se).getRef();
        _switchResult = this.getName(_ref);
      }
    }
    return _switchResult;
  }
  
  public String getStoreType(final StoreExpression se) {
    String _switchResult = null;
    boolean _matched = false;
    if (!_matched) {
      if (se instanceof Store) {
        _matched=true;
        _switchResult = "sto";
      }
    }
    if (!_matched) {
      if (se instanceof Reference) {
        _matched=true;
        _switchResult = "ref";
      }
    }
    if (!_matched) {
      if (se instanceof SelfReference) {
        _matched=true;
        _switchResult = "sel";
      }
    }
    if (!_matched) {
      if (se instanceof PredicateStoreReference) {
        _matched=true;
        StoreExpression _ref = ((PredicateStoreReference)se).getRef();
        _switchResult = this.getStoreType(_ref);
      }
    }
    if (!_matched) {
      if (se instanceof OutStoreReference) {
        _matched=true;
        StoreExpression _ref = ((OutStoreReference)se).getRef();
        _switchResult = this.getStoreType(_ref);
      }
    }
    if (!_matched) {
      if (se instanceof UpdateStoreReference) {
        _matched=true;
        StoreExpression _ref = ((UpdateStoreReference)se).getRef();
        _switchResult = this.getStoreType(_ref);
      }
    }
    if (!_matched) {
      if (se instanceof UpdateExpressionStoreReference) {
        _matched=true;
        StoreExpression _ref = ((UpdateExpressionStoreReference)se).getRef();
        _switchResult = this.getStoreType(_ref);
      }
    }
    if (!_matched) {
      if (se instanceof DistributionReference) {
        _matched=true;
        StoreExpression _ref = ((DistributionReference)se).getRef();
        _switchResult = this.getStoreType(_ref);
      }
    }
    if (!_matched) {
      if (se instanceof UniformReference) {
        _matched=true;
        StoreExpression _ref = ((UniformReference)se).getRef();
        _switchResult = this.getStoreType(_ref);
      }
    }
    return _switchResult;
  }
  
  public String check(final PredicateStoreReference sr) {
    StoreExpression _ref = sr.getRef();
    boolean _isReferenceSeenInTerms = this.isReferenceSeenInTerms(_ref);
    boolean _not = (!_isReferenceSeenInTerms);
    if (_not) {
      return "\' does not refer to a declared store.";
    }
    return "";
  }
  
  public String check(final OutStoreReference sr) {
    StoreExpression _ref = sr.getRef();
    boolean _isReferenceSeenInTerms = this.isReferenceSeenInTerms(_ref);
    boolean _not = (!_isReferenceSeenInTerms);
    if (_not) {
      return "\' does not refer to a declared store.";
    }
    return "";
  }
  
  public String check(final UpdateStoreReference sr) {
    StoreExpression _ref = sr.getRef();
    boolean _isReferenceSeenInTerms = this.isReferenceSeenInTerms(_ref);
    boolean _not = (!_isReferenceSeenInTerms);
    if (_not) {
      return "\' does not refer to a declared store.";
    }
    return "";
  }
  
  public boolean isReferenceSeenInTerms(final StoreExpression sr) {
    String _name = this.getName(sr);
    Set<eu.quanticol.cASPA.Process> _fromStoreExpressionGetProcesses = this._modelUtil.fromStoreExpressionGetProcesses(sr);
    HashMap<Integer, Term> _fromProcessesGetHashMapOfTerms = this._modelUtil.fromProcessesGetHashMapOfTerms(_fromStoreExpressionGetProcesses);
    HashMap<Integer, ArrayList<String>> _fromHashMapOfTermsGetStoreNames = this._modelUtil.fromHashMapOfTermsGetStoreNames(_fromProcessesGetHashMapOfTerms);
    return this._modelUtil.isInMap(_name, _fromHashMapOfTermsGetStoreNames);
  }
  
  public String check(final UpdateExpressionStoreReference sr) {
    ProcessExpression _containerOfType = EcoreUtil2.<ProcessExpression>getContainerOfType(sr, ProcessExpression.class);
    List<In> _allContentsOfType = EcoreUtil2.<In>getAllContentsOfType(_containerOfType, In.class);
    int _length = ((Object[])Conversions.unwrapArray(_allContentsOfType, Object.class)).length;
    boolean _greaterThan = (_length > 0);
    if (_greaterThan) {
      String _storeType = this.getStoreType(sr);
      boolean _equals = _storeType.equals("sel");
      if (_equals) {
        StoreExpression _ref = sr.getRef();
        boolean _isReferenceSeenInTerms = this.isReferenceSeenInTerms(_ref);
        boolean _not = (!_isReferenceSeenInTerms);
        if (_not) {
          return "\' does not refer to a declared store.";
        }
      }
      StoreExpression _ref_1 = sr.getRef();
      boolean _isReferenceSeenInTerms_1 = this.isReferenceSeenInTerms(_ref_1);
      boolean _not_1 = (!_isReferenceSeenInTerms_1);
      if (_not_1) {
        StoreExpression _ref_2 = sr.getRef();
        boolean _isReferenceSeenInInputArguments = this.isReferenceSeenInInputArguments(_ref_2);
        boolean _not_2 = (!_isReferenceSeenInInputArguments);
        if (_not_2) {
          return "\' does not refer to a declared store or free variable.";
        }
      }
      return "";
    } else {
      StoreExpression _ref_3 = sr.getRef();
      boolean _isReferenceSeenInTerms_2 = this.isReferenceSeenInTerms(_ref_3);
      boolean _not_3 = (!_isReferenceSeenInTerms_2);
      if (_not_3) {
        return "\' does not refer to a declared store.";
      }
      return "";
    }
  }
  
  public String check(final DistributionReference sr) {
    StoreExpression _ref = sr.getRef();
    boolean _isReferenceSeenInTerms = this.isReferenceSeenInTerms(_ref);
    boolean _not = (!_isReferenceSeenInTerms);
    if (_not) {
      String _storeType = this.getStoreType(sr);
      boolean _equals = _storeType.equals("sel");
      if (_equals) {
        StoreExpression _ref_1 = sr.getRef();
        boolean _isReferenceSeenInTerms_1 = this.isReferenceSeenInTerms(_ref_1);
        boolean _not_1 = (!_isReferenceSeenInTerms_1);
        if (_not_1) {
          return "\' does not refer to a declared store.";
        }
      }
    }
    StoreExpression _ref_2 = sr.getRef();
    boolean _isReferenceSeenInInputArguments = this.isReferenceSeenInInputArguments(_ref_2);
    boolean _not_2 = (!_isReferenceSeenInInputArguments);
    if (_not_2) {
      return "\' does not refer to a declared store or free variable.";
    }
    return "";
  }
  
  public String check(final UniformReference sr) {
    StoreExpression _ref = sr.getRef();
    boolean _isReferenceSeenInTerms = this.isReferenceSeenInTerms(_ref);
    boolean _not = (!_isReferenceSeenInTerms);
    if (_not) {
      String _storeType = this.getStoreType(sr);
      boolean _equals = _storeType.equals("sel");
      if (_equals) {
        StoreExpression _ref_1 = sr.getRef();
        boolean _isReferenceSeenInTerms_1 = this.isReferenceSeenInTerms(_ref_1);
        boolean _not_1 = (!_isReferenceSeenInTerms_1);
        if (_not_1) {
          return "\' does not refer to a declared store.";
        }
      }
    }
    StoreExpression _ref_2 = sr.getRef();
    boolean _isReferenceSeenInInputArguments = this.isReferenceSeenInInputArguments(_ref_2);
    boolean _not_2 = (!_isReferenceSeenInInputArguments);
    if (_not_2) {
      return "\' does not refer to a declared store or free variable.";
    }
    return "";
  }
  
  public boolean isReferenceSeenInInputArguments(final StoreExpression sr) {
    String _name = this.getName(sr);
    ArrayList<String> _fromStoreExpressionGetProcessInArgs = this._modelUtil.fromStoreExpressionGetProcessInArgs(sr);
    return this._modelUtil.isInList(_name, _fromStoreExpressionGetProcessInArgs);
  }
}
