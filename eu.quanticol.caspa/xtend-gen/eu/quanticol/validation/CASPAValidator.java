/**
 * generated by Xtext
 */
package eu.quanticol.validation;

import com.google.common.base.Objects;
import com.google.inject.Inject;
import eu.quanticol.ModelUtil;
import eu.quanticol.cASPA.Arguments;
import eu.quanticol.cASPA.CASPAPackage;
import eu.quanticol.cASPA.DistributionReference;
import eu.quanticol.cASPA.FreeVariable;
import eu.quanticol.cASPA.In;
import eu.quanticol.cASPA.LocalSingleEventUpdate;
import eu.quanticol.cASPA.Model;
import eu.quanticol.cASPA.OutStoreReference;
import eu.quanticol.cASPA.Predicate;
import eu.quanticol.cASPA.PredicateAnd;
import eu.quanticol.cASPA.PredicateComparison;
import eu.quanticol.cASPA.PredicateDiv;
import eu.quanticol.cASPA.PredicateEquality;
import eu.quanticol.cASPA.PredicateExpression;
import eu.quanticol.cASPA.PredicateMul;
import eu.quanticol.cASPA.PredicateNot;
import eu.quanticol.cASPA.PredicateOr;
import eu.quanticol.cASPA.PredicatePlu;
import eu.quanticol.cASPA.PredicateStoreReference;
import eu.quanticol.cASPA.PredicateSub;
import eu.quanticol.cASPA.SelfReference;
import eu.quanticol.cASPA.StoreExpression;
import eu.quanticol.cASPA.Term;
import eu.quanticol.cASPA.UniformReference;
import eu.quanticol.cASPA.UpdateDiv;
import eu.quanticol.cASPA.UpdateExpression;
import eu.quanticol.cASPA.UpdateExpressionStoreReference;
import eu.quanticol.cASPA.UpdateMul;
import eu.quanticol.cASPA.UpdatePlu;
import eu.quanticol.cASPA.UpdateSub;
import eu.quanticol.typing.BaseType;
import eu.quanticol.typing.TypeProvider;
import eu.quanticol.validation.AbstractCASPAValidator;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EAttribute;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Extension;
import org.eclipse.xtext.xbase.lib.InputOutput;

/**
 * Custom validation rules.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
@SuppressWarnings("all")
public class CASPAValidator extends AbstractCASPAValidator {
  @Inject
  @Extension
  private TypeProvider _typeProvider;
  
  @Inject
  @Extension
  private ModelUtil _modelUtil;
  
  public final static String PROCESS_NAMES_UNIQUE = "eu.quanticol.processNamesUnique";
  
  public final static String WRONG_TYPE = "eu.quanticol.WrongType";
  
  public final static String FREE_VARIABLES_UNIQUE = "eu.quanticol.freeVariablesUnique";
  
  public final static String SELF_REFERENCE_HAS_REFERENCE = "eu.quanticol.selfReferenceHasReference";
  
  @Check
  public void checkProcessNamesUnique(final eu.quanticol.cASPA.Process process) {
    Model _containerOfType = EcoreUtil2.<Model>getContainerOfType(process, Model.class);
    EList<eu.quanticol.cASPA.Process> processes = _containerOfType.getProcesses();
    int count = 0;
    for (final eu.quanticol.cASPA.Process proc : processes) {
      String _name = proc.getName();
      String _name_1 = process.getName();
      boolean _equals = _name.equals(_name_1);
      if (_equals) {
        count = (count + 1);
      }
    }
    if ((count == 1)) {
      return;
    } else {
      String _name_2 = process.getName();
      String _plus = ("Must have unique process names. \'" + _name_2);
      String _plus_1 = (_plus + "\' is repeated");
      EAttribute _process_Name = CASPAPackage.eINSTANCE.getProcess_Name();
      this.error(_plus_1, _process_Name, 
        CASPAValidator.PROCESS_NAMES_UNIQUE);
    }
  }
  
  @Check
  public void checkType(final Predicate predicate) {
    PredicateExpression _predicate = predicate.getPredicate();
    this.checkExpectedBoolean(_predicate, CASPAPackage.Literals.PREDICATE__PREDICATE);
  }
  
  @Check
  public void checkType(final PredicateOr p) {
    PredicateExpression _left = p.getLeft();
    this.checkExpectedBoolean(_left, CASPAPackage.Literals.PREDICATE_OR__LEFT);
    PredicateExpression _right = p.getRight();
    this.checkExpectedBoolean(_right, CASPAPackage.Literals.PREDICATE_OR__RIGHT);
  }
  
  @Check
  public void checkType(final PredicateAnd p) {
    PredicateExpression _left = p.getLeft();
    this.checkExpectedBoolean(_left, CASPAPackage.Literals.PREDICATE_AND__LEFT);
    PredicateExpression _right = p.getRight();
    this.checkExpectedBoolean(_right, CASPAPackage.Literals.PREDICATE_AND__RIGHT);
  }
  
  @Check
  public void checkType(final PredicateEquality p) {
    PredicateExpression _left = p.getLeft();
    this.checkExpectedInt(_left, CASPAPackage.Literals.PREDICATE_EQUALITY__LEFT);
    PredicateExpression _right = p.getRight();
    this.checkExpectedInt(_right, CASPAPackage.Literals.PREDICATE_EQUALITY__RIGHT);
  }
  
  @Check
  public void checkType(final PredicateComparison p) {
    PredicateExpression _left = p.getLeft();
    this.checkExpectedInt(_left, CASPAPackage.Literals.PREDICATE_COMPARISON__LEFT);
    PredicateExpression _right = p.getRight();
    this.checkExpectedInt(_right, CASPAPackage.Literals.PREDICATE_COMPARISON__RIGHT);
  }
  
  @Check
  public void checkType(final PredicateSub p) {
    PredicateExpression _left = p.getLeft();
    this.checkExpectedInt(_left, CASPAPackage.Literals.PREDICATE_SUB__LEFT);
    PredicateExpression _right = p.getRight();
    this.checkExpectedInt(_right, CASPAPackage.Literals.PREDICATE_SUB__RIGHT);
  }
  
  @Check
  public void checkType(final PredicatePlu p) {
    PredicateExpression _left = p.getLeft();
    this.checkExpectedInt(_left, CASPAPackage.Literals.PREDICATE_PLU__LEFT);
    PredicateExpression _right = p.getRight();
    this.checkExpectedInt(_right, CASPAPackage.Literals.PREDICATE_PLU__RIGHT);
  }
  
  @Check
  public void checkType(final PredicateMul p) {
    PredicateExpression _left = p.getLeft();
    this.checkExpectedInt(_left, CASPAPackage.Literals.PREDICATE_MUL__LEFT);
    PredicateExpression _right = p.getRight();
    this.checkExpectedInt(_right, CASPAPackage.Literals.PREDICATE_MUL__RIGHT);
  }
  
  @Check
  public void checkType(final PredicateDiv p) {
    PredicateExpression _left = p.getLeft();
    this.checkExpectedInt(_left, CASPAPackage.Literals.PREDICATE_DIV__LEFT);
    PredicateExpression _right = p.getRight();
    this.checkExpectedInt(_right, CASPAPackage.Literals.PREDICATE_DIV__RIGHT);
  }
  
  @Check
  public void checkType(final PredicateNot p) {
    PredicateExpression _expression = p.getExpression();
    this.checkExpectedBoolean(_expression, CASPAPackage.Literals.PREDICATE_NOT__EXPRESSION);
  }
  
  private void checkExpectedBoolean(final PredicateExpression exp, final EReference reference) {
    this.checkExpectedType(exp, TypeProvider.boolConstantType, reference);
  }
  
  private void checkExpectedInt(final PredicateExpression exp, final EReference reference) {
    this.checkExpectedType(exp, TypeProvider.constantType, reference);
  }
  
  private void checkExpectedType(final PredicateExpression exp, final BaseType expectedType, final EReference reference) {
    final BaseType actualType = this.getTypeAndCheckNotNull(exp, reference);
    boolean _notEquals = (!Objects.equal(actualType, expectedType));
    if (_notEquals) {
      this.error(((("expected " + expectedType) + " type, but was ") + actualType), reference, CASPAValidator.WRONG_TYPE);
    }
  }
  
  private BaseType getTypeAndCheckNotNull(final PredicateExpression exp, final EReference reference) {
    BaseType _typeFor = null;
    if (exp!=null) {
      _typeFor=this._typeProvider.typeFor(exp);
    }
    BaseType type = _typeFor;
    boolean _equals = Objects.equal(type, null);
    if (_equals) {
      this.error("null type", reference, CASPAValidator.WRONG_TYPE);
    }
    return type;
  }
  
  @Check
  public void checkType(final LocalSingleEventUpdate update) {
    UpdateExpression _assigner = update.getAssigner();
    this.checkExpectedInt(_assigner, CASPAPackage.Literals.LOCAL_SINGLE_EVENT_UPDATE__ASSIGNER);
  }
  
  @Check
  public void checkType(final UpdateSub p) {
    UpdateExpression _left = p.getLeft();
    this.checkExpectedInt(_left, CASPAPackage.Literals.UPDATE_SUB__LEFT);
    UpdateExpression _right = p.getRight();
    this.checkExpectedInt(_right, CASPAPackage.Literals.UPDATE_SUB__RIGHT);
  }
  
  @Check
  public void checkType(final UpdatePlu p) {
    UpdateExpression _left = p.getLeft();
    this.checkExpectedInt(_left, CASPAPackage.Literals.UPDATE_PLU__LEFT);
    UpdateExpression _right = p.getRight();
    this.checkExpectedInt(_right, CASPAPackage.Literals.UPDATE_PLU__RIGHT);
  }
  
  @Check
  public void checkType(final UpdateMul p) {
    UpdateExpression _left = p.getLeft();
    this.checkExpectedInt(_left, CASPAPackage.Literals.UPDATE_MUL__LEFT);
    UpdateExpression _right = p.getRight();
    this.checkExpectedInt(_right, CASPAPackage.Literals.UPDATE_MUL__RIGHT);
  }
  
  @Check
  public void checkType(final UpdateDiv p) {
    UpdateExpression _left = p.getLeft();
    this.checkExpectedInt(_left, CASPAPackage.Literals.UPDATE_DIV__LEFT);
    UpdateExpression _right = p.getRight();
    this.checkExpectedInt(_right, CASPAPackage.Literals.UPDATE_DIV__RIGHT);
  }
  
  private void checkExpectedInt(final UpdateExpression exp, final EReference reference) {
    this.checkExpectedType(exp, TypeProvider.constantType, reference);
  }
  
  private void checkExpectedType(final UpdateExpression exp, final BaseType expectedType, final EReference reference) {
    final BaseType actualType = this.getTypeAndCheckNotNull(exp, reference);
    boolean _notEquals = (!Objects.equal(actualType, expectedType));
    if (_notEquals) {
      this.error(((("expected " + expectedType) + " type, but was ") + actualType), reference, CASPAValidator.WRONG_TYPE);
    }
  }
  
  private BaseType getTypeAndCheckNotNull(final UpdateExpression exp, final EReference reference) {
    BaseType _typeFor = null;
    if (exp!=null) {
      _typeFor=this._typeProvider.typeFor(exp);
    }
    BaseType type = _typeFor;
    boolean _equals = Objects.equal(type, null);
    if (_equals) {
      this.error("null type", reference, CASPAValidator.WRONG_TYPE);
    }
    return type;
  }
  
  @Check
  public void checkFreeVariableNamesUnique(final In in) {
    Set<String> freeVariableNames = new HashSet<String>();
    Set<String> allParentTermsStoreNames = new HashSet<String>();
    Set<String> temp = new HashSet<String>();
    EList<Arguments> _expressions = in.getExpressions();
    for (final Arguments expression : _expressions) {
      String _name = ((FreeVariable) expression).getName();
      freeVariableNames.add(_name);
    }
    eu.quanticol.cASPA.Process _fromInGetProcess = this._modelUtil.fromInGetProcess(in);
    Set<eu.quanticol.cASPA.Process> _fromProcessGetReferences = this._modelUtil.fromProcessGetReferences(_fromInGetProcess);
    Set<Term> _parentTerms = this._modelUtil.getParentTerms(_fromProcessGetReferences);
    Set<String> _storeNamesFromTerms = this._modelUtil.getStoreNamesFromTerms(_parentTerms);
    allParentTermsStoreNames = _storeNamesFromTerms;
    for (final String name : allParentTermsStoreNames) {
      temp.add(name);
    }
    temp.removeAll(freeVariableNames);
    int _size = temp.size();
    int _size_1 = allParentTermsStoreNames.size();
    boolean _notEquals = (_size != _size_1);
    if (_notEquals) {
      EReference _in_Expressions = CASPAPackage.eINSTANCE.getIn_Expressions();
      this.error("Free variable names cannot be the same as local store names.", _in_Expressions, 
        CASPAValidator.FREE_VARIABLES_UNIQUE);
    }
  }
  
  @Check
  public void checkSelfReferences(final StoreExpression sr) {
    String result = "";
    boolean _matched = false;
    if (!_matched) {
      if (sr instanceof PredicateStoreReference) {
        _matched=true;
        this.test(((PredicateStoreReference)sr));
      }
    }
    if (!_matched) {
      if (sr instanceof OutStoreReference) {
        _matched=true;
        InputOutput.<String>println(("osr " + sr));
      }
    }
    if (!_matched) {
      if (sr instanceof UpdateExpressionStoreReference) {
        _matched=true;
        InputOutput.<String>println(("uesr " + sr));
      }
    }
    if (!_matched) {
      if (sr instanceof DistributionReference) {
        _matched=true;
        InputOutput.<String>println(("dr " + sr));
      }
    }
    if (!_matched) {
      if (sr instanceof UniformReference) {
        _matched=true;
        InputOutput.<String>println(("ur " + sr));
      }
    }
    int _length = result.length();
    boolean _notEquals = (_length != 0);
    if (_notEquals) {
      EAttribute _reference_Name = CASPAPackage.eINSTANCE.getReference_Name();
      this.error(result, _reference_Name, 
        CASPAValidator.SELF_REFERENCE_HAS_REFERENCE);
    }
  }
  
  public String test(final PredicateStoreReference sr) {
    boolean _allReferencesAreSeen = this.allReferencesAreSeen(sr);
    boolean _not = (!_allReferencesAreSeen);
    if (_not) {
      return "This reference does not refer to a declared store.";
    } else {
      return "";
    }
  }
  
  public boolean allReferencesAreSeen(final PredicateStoreReference sr) {
    StoreExpression _ref = sr.getRef();
    String _name = ((SelfReference) _ref).getName();
    Set<eu.quanticol.cASPA.Process> _parentProcesses = this._modelUtil.getParentProcesses(sr);
    HashMap<Integer, Term> _parentTermsHash = this._modelUtil.getParentTermsHash(_parentProcesses);
    HashMap<Integer, ArrayList<String>> _storeNamesFromTermsHashMap = this._modelUtil.getStoreNamesFromTermsHashMap(_parentTermsHash);
    return this._modelUtil.isInMap(_name, _storeNamesFromTermsHashMap);
  }
}
