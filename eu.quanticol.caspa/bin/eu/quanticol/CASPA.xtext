grammar eu.quanticol.CASPA with org.eclipse.xtext.common.Terminals

generate cASPA "http://www.quanticol.eu/CASPA"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Model hidden(ML_COMMENT,SL_COMMENT,WS):
	stores+=Store+ 
	processes+=Process+ 
	terms+=Term+ 
;

//STORE
Store hidden(ML_COMMENT,SL_COMMENT,WS):
	name=LOWER "=" value=Natural ";"
;

ReferencedStore hidden(ML_COMMENT,SL_COMMENT,WS):
	{ReferencedStore} name=[Store|LOWER]
;

SelfReferencedStore hidden(ML_COMMENT,SL_COMMENT,WS):
	{SelfReferencedStore}   "this."name=[Store|LOWER]
;

/**  Old Store expressions
StoreExpression hidden(ML_COMMENT,SL_COMMENT,WS):
	StoreOr ";"
;
	
StoreOr returns StoreExpression hidden(ML_COMMENT,SL_COMMENT,WS):
	StoreAnd ({StoreOr.left=current} "||" 
		right=StoreAnd
	)*
;

StoreAnd returns StoreExpression hidden(ML_COMMENT,SL_COMMENT,WS):
	StoreEquality ({StoreAnd.left=current} "&&" 
		right=StoreEquality
	)*
;

StoreEquality returns StoreExpression hidden(ML_COMMENT,SL_COMMENT,WS):
	StoreComparison (
		{StoreEquality.left=current} op=("=="|"!=")
		right=StoreComparison
	)*
;

StoreComparison returns StoreExpression hidden(ML_COMMENT,SL_COMMENT,WS):
	StoreSubtraction ({StoreComparison.left=current} op=(">="|"<="|">"|"<") 
		right=StoreSubtraction
	)*
;
	
StoreSubtraction returns StoreExpression hidden(ML_COMMENT,SL_COMMENT,WS):
	StoreAddition ({StoreSub.left=current} '-' 
		right=StoreAddition
	)*
;
	
StoreAddition returns StoreExpression hidden(ML_COMMENT,SL_COMMENT,WS):
	StoreMultiplication ({StorePlu.left=current} '+' 
		right=StoreMultiplication
	)*
;

StoreMultiplication returns StoreExpression hidden(ML_COMMENT,SL_COMMENT,WS):
	StoreDivision ({StoreMul.left=current} '*' 
		right=StoreDivision
	)*
;
	
StoreDivision returns StoreExpression hidden(ML_COMMENT,SL_COMMENT,WS): 
	StorePrimary ({StoreDiv.left=current} '/' 
		right=StorePrimary
	)*
;

StorePrimary returns StoreExpression hidden(ML_COMMENT,SL_COMMENT,WS):
	'(' StoreExpression ')' | 
	{StoreNot} "!" expression=StorePrimary |
	StoreAtomic
;

StoreAtomic returns StoreExpression hidden(ML_COMMENT,SL_COMMENT,WS):
	{DoubleConstant} 	value=Double |
	{BoolConstant} 		value=('true'|'false') |
	ReferencedStore
;
 **/

//ACTIONS
Action hidden(ML_COMMENT,SL_COMMENT,WS):
	({Broadcast} name=LOWER "*" | {Unicast} name=LOWER) (predicate=Predicate)? (arguments=Arguments)? (updates=Updates)? "." 
	
;

//PREDICATE
Predicate hidden(ML_COMMENT,SL_COMMENT,WS) :
	{Predicate} "[" predicate=PredicateExpression "]"
;

PredicateExpression hidden(ML_COMMENT,SL_COMMENT,WS):
	PredicateOr ";"
;
	
PredicateOr returns PredicateExpression hidden(ML_COMMENT,SL_COMMENT,WS):
	PredicateAnd ({PredicateOr.left=current} "||" 
		right=PredicateAnd
	)*
;

PredicateAnd returns PredicateExpression hidden(ML_COMMENT,SL_COMMENT,WS):
	PredicateEquality ({PredicateAnd.left=current} "&&" 
		right=PredicateEquality
	)*
;

PredicateEquality returns PredicateExpression hidden(ML_COMMENT,SL_COMMENT,WS):
	PredicateComparison (
		{PredicateEquality.left=current} op=("=="|"!=")
		right=PredicateComparison
	)*
;

PredicateComparison returns PredicateExpression hidden(ML_COMMENT,SL_COMMENT,WS):
	PredicateSubtraction ({PredicateComparison.left=current} op=(">="|"<="|">"|"<") 
		right=PredicateSubtraction
	)*
;
	
PredicateSubtraction returns PredicateExpression hidden(ML_COMMENT,SL_COMMENT,WS):
	PredicateAddition ({PredicateSub.left=current} '-' 
		right=PredicateAddition
	)*
;
	
PredicateAddition returns PredicateExpression hidden(ML_COMMENT,SL_COMMENT,WS):
	PredicateMultiplication ({PredicatePlu.left=current} '+' 
		right=PredicateMultiplication
	)*
;

PredicateMultiplication returns PredicateExpression hidden(ML_COMMENT,SL_COMMENT,WS):
	PredicateDivision ({PredicateMul.left=current} '*' 
		right=PredicateDivision
	)*
;
	
PredicateDivision returns PredicateExpression hidden(ML_COMMENT,SL_COMMENT,WS): 
	PredicatePrimary ({PredicateDiv.left=current} '/' 
		right=PredicatePrimary
	)*
;

PredicatePrimary returns PredicateExpression hidden(ML_COMMENT,SL_COMMENT,WS):
	'(' PredicateExpression ')' | 
	{Not} "!" expression=PredicatePrimary |
	PredicateAtomic
;

PredicateAtomic returns PredicateExpression hidden(ML_COMMENT,SL_COMMENT,WS):
	{Constant} 	value=Natural |
	{Bool} value=Bool |
	ReferencedStore |
	SelfReferencedStore
;

//ARGUMENTS
Arguments hidden(ML_COMMENT,SL_COMMENT,WS):
	 ("(" {In} expressions+=InArguments+ ")"| "<" {Out} expressions+=OutArguments+ ">")
;

InArguments hidden(ML_COMMENT,SL_COMMENT,WS):
	Variables
;

OutArguments hidden(ML_COMMENT,SL_COMMENT,WS):
	Expressions
;

Expressions hidden(ML_COMMENT,SL_COMMENT,WS):
	SelfReferencedStore | 
	ReferencedStore |
	value=Natural
;

Variables hidden(ML_COMMENT,SL_COMMENT,WS):
	SelfReferencedStore | 
	ReferencedStore
;

//UPDATES
Updates hidden(ML_COMMENT,SL_COMMENT,WS):
	{Updates} "{" updates+=Update+ "}"
;


Update hidden(ML_COMMENT,SL_COMMENT,WS):
	(SingleEventUpdate | DistributedEventUpdate) ";"
;

SingleEventUpdate hidden(ML_COMMENT,SL_COMMENT,WS):
	{LocalSingleEventUpdate} name=SelfReferencedStore ":=" expression=UpdateExpression  // | 
	//{GlobalSingleEventUpdate} name=[Store|LOWER] ":=" expression=ActionExpression
;

DistributedEventUpdate hidden(ML_COMMENT,SL_COMMENT,WS):
	{DistributedEventUpdateProbability} "Pr" "(" distribution+=Distribution+ ")" |
	{DistributedEventUpdateUniform} "U" "(" distribution+=Uniform ")"
;

Distribution hidden(ML_COMMENT,SL_COMMENT,WS):
	{Distribution} prob=Double ":" expression=UpdateExpression ";"
;

Uniform hidden(ML_COMMENT,SL_COMMENT,WS):
	{Uniform} expression=UpdateExpression ";"
;

UpdateExpression hidden(ML_COMMENT,SL_COMMENT,WS):
	UpdateOr
;
	
UpdateOr returns UpdateExpression hidden(ML_COMMENT,SL_COMMENT,WS):
	UpdateAnd ({UpdateOr.left=current} "||" 
		right=UpdateAnd
	)*
;

UpdateAnd returns UpdateExpression hidden(ML_COMMENT,SL_COMMENT,WS):
	UpdateEquality ({UpdateAnd.left=current} "&&" 
		right=UpdateEquality
	)*
;

UpdateEquality returns UpdateExpression hidden(ML_COMMENT,SL_COMMENT,WS):
	UpdateComparison (
		{UpdateEquality.left=current} op=("=="|"!=")
		right=UpdateComparison
	)*
;

UpdateComparison returns UpdateExpression hidden(ML_COMMENT,SL_COMMENT,WS):
	UpdateSubtraction ({UpdateComparison.left=current} op=(">="|"<="|">"|"<") 
		right=UpdateSubtraction
	)*
;
	
UpdateSubtraction returns UpdateExpression hidden(ML_COMMENT,SL_COMMENT,WS):
	UpdateAddition ({UpdateSub.left=current} '-' 
		right=UpdateAddition
	)*
;
	
UpdateAddition returns UpdateExpression hidden(ML_COMMENT,SL_COMMENT,WS):
	UpdateMultiplication ({UpdatePlu.left=current} '+' 
		right=UpdateMultiplication
	)*
;

UpdateMultiplication returns UpdateExpression hidden(ML_COMMENT,SL_COMMENT,WS):
	UpdateDivision ({UpdateMul.left=current} '*' 
		right=UpdateDivision
	)*
;
	
UpdateDivision returns UpdateExpression hidden(ML_COMMENT,SL_COMMENT,WS): 
	UpdatePrimary ({UpdateDiv.left=current} '/' 
		right=UpdatePrimary
	)*
;

UpdatePrimary returns UpdateExpression hidden(ML_COMMENT,SL_COMMENT,WS):
	'(' UpdateExpression ')' | 
	{UpdateNot} "!" expression=UpdatePrimary |
	UpdateAtomic
;

UpdateAtomic returns UpdateExpression hidden(ML_COMMENT,SL_COMMENT,WS):
	{Constant} 	value=Natural |
	{Bool} value=Bool |
	ReferencedStore |
	SelfReferencedStore
;


//PROCESSES
Process hidden(ML_COMMENT,SL_COMMENT,WS):
	name=UPPER "=" value=ProcessExpression ";"
;

ProcessExpression returns ProcessExpression hidden(ML_COMMENT,SL_COMMENT,WS):
	Parallel
;

Parallel returns ProcessExpression hidden(ML_COMMENT,SL_COMMENT,WS):
	Choice ({Parallel.left=current}  "|" right=Choice)*
;

Choice returns ProcessExpression hidden(ML_COMMENT,SL_COMMENT,WS):
	PrimaryProcess ({Choice.left=current}  "+" right=PrimaryProcess)*
;

PrimaryProcess returns ProcessExpression hidden(ML_COMMENT,SL_COMMENT,WS):
	{Leaf} value="nil" |
	{Leaf} value="kill"|
	PredicateProcess |
	ActionProcess |
	{ProcessReference} value=[Process|UPPER]
;

PredicateProcess hidden(ML_COMMENT,SL_COMMENT,WS):
	{PredicateProcess} predicate=Predicate value=[Process|UPPER]
;

ActionProcess hidden(ML_COMMENT,SL_COMMENT,WS):
	{ActionProcess} action=Action value=[Process|UPPER]
;


//TERMS
Term hidden(ML_COMMENT,SL_COMMENT,WS):
	"(" name=[Process|UPPER] ",""{" stores+=[Store|LOWER] "}" ")"";"
;

Double returns ecore::EDouble:
	 INT ('.' INT ('e'|'E' '-'? INT)?)?
;

Natural returns ecore::EInt:
	NAT
;

Bool returns ecore::EBoolean:
	('true'|'false')
;

terminal LOWER: ("a".."z") ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;
terminal UPPER: ("A".."Z") ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;
terminal NAT: ('0'..'9')+;