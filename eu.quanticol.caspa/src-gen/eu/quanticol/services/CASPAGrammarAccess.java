/*
* generated by Xtext
*/
package eu.quanticol.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import org.eclipse.xtext.common.services.TerminalsGrammarAccess;

@Singleton
public class CASPAGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class ModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Model");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cStoresAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cStoresStoreParserRuleCall_0_0 = (RuleCall)cStoresAssignment_0.eContents().get(0);
		private final Assignment cProcessesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cProcessesProcessParserRuleCall_1_0 = (RuleCall)cProcessesAssignment_1.eContents().get(0);
		private final Assignment cTermsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTermsTermParserRuleCall_2_0 = (RuleCall)cTermsAssignment_2.eContents().get(0);
		
		//Model hidden(ML_COMMENT, SL_COMMENT, WS):
		//	stores+=Store+ processes+=Process+ terms+=Term+;
		public ParserRule getRule() { return rule; }

		//stores+=Store+ processes+=Process+ terms+=Term+
		public Group getGroup() { return cGroup; }

		//stores+=Store+
		public Assignment getStoresAssignment_0() { return cStoresAssignment_0; }

		//Store
		public RuleCall getStoresStoreParserRuleCall_0_0() { return cStoresStoreParserRuleCall_0_0; }

		//processes+=Process+
		public Assignment getProcessesAssignment_1() { return cProcessesAssignment_1; }

		//Process
		public RuleCall getProcessesProcessParserRuleCall_1_0() { return cProcessesProcessParserRuleCall_1_0; }

		//terms+=Term+
		public Assignment getTermsAssignment_2() { return cTermsAssignment_2; }

		//Term
		public RuleCall getTermsTermParserRuleCall_2_0() { return cTermsTermParserRuleCall_2_0; }
	}

	public class StoreElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Store");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameLOWERTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cValueAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValueNaturalParserRuleCall_2_0 = (RuleCall)cValueAssignment_2.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		////STORE
		//Store hidden(ML_COMMENT, SL_COMMENT, WS):
		//	name=LOWER "=" value=Natural ";";
		public ParserRule getRule() { return rule; }

		//name=LOWER "=" value=Natural ";"
		public Group getGroup() { return cGroup; }

		//name=LOWER
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//LOWER
		public RuleCall getNameLOWERTerminalRuleCall_0_0() { return cNameLOWERTerminalRuleCall_0_0; }

		//"="
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }

		//value=Natural
		public Assignment getValueAssignment_2() { return cValueAssignment_2; }

		//Natural
		public RuleCall getValueNaturalParserRuleCall_2_0() { return cValueNaturalParserRuleCall_2_0; }

		//";"
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}

	public class ReferencedStoreElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ReferencedStore");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cReferencedStoreAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cNameStoreCrossReference_1_0 = (CrossReference)cNameAssignment_1.eContents().get(0);
		private final RuleCall cNameStoreLOWERTerminalRuleCall_1_0_1 = (RuleCall)cNameStoreCrossReference_1_0.eContents().get(1);
		
		//ReferencedStore hidden(ML_COMMENT, SL_COMMENT, WS):
		//	{ReferencedStore} name=[Store|LOWER];
		public ParserRule getRule() { return rule; }

		//{ReferencedStore} name=[Store|LOWER]
		public Group getGroup() { return cGroup; }

		//{ReferencedStore}
		public Action getReferencedStoreAction_0() { return cReferencedStoreAction_0; }

		//name=[Store|LOWER]
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//[Store|LOWER]
		public CrossReference getNameStoreCrossReference_1_0() { return cNameStoreCrossReference_1_0; }

		//LOWER
		public RuleCall getNameStoreLOWERTerminalRuleCall_1_0_1() { return cNameStoreLOWERTerminalRuleCall_1_0_1; }
	}

	public class SelfReferencedStoreElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SelfReferencedStore");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cSelfReferencedStoreAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cThisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cNameStoreCrossReference_2_0 = (CrossReference)cNameAssignment_2.eContents().get(0);
		private final RuleCall cNameStoreLOWERTerminalRuleCall_2_0_1 = (RuleCall)cNameStoreCrossReference_2_0.eContents().get(1);
		
		//SelfReferencedStore hidden(ML_COMMENT, SL_COMMENT, WS):
		//	{SelfReferencedStore} "this." name=[Store|LOWER];
		public ParserRule getRule() { return rule; }

		//{SelfReferencedStore} "this." name=[Store|LOWER]
		public Group getGroup() { return cGroup; }

		//{SelfReferencedStore}
		public Action getSelfReferencedStoreAction_0() { return cSelfReferencedStoreAction_0; }

		//"this."
		public Keyword getThisKeyword_1() { return cThisKeyword_1; }

		//name=[Store|LOWER]
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }

		//[Store|LOWER]
		public CrossReference getNameStoreCrossReference_2_0() { return cNameStoreCrossReference_2_0; }

		//LOWER
		public RuleCall getNameStoreLOWERTerminalRuleCall_2_0_1() { return cNameStoreLOWERTerminalRuleCall_2_0_1; }
	}

	public class ActionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Action");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Group cGroup_0_0 = (Group)cAlternatives_0.eContents().get(0);
		private final Action cBroadcastAction_0_0_0 = (Action)cGroup_0_0.eContents().get(0);
		private final Assignment cNameAssignment_0_0_1 = (Assignment)cGroup_0_0.eContents().get(1);
		private final RuleCall cNameLOWERTerminalRuleCall_0_0_1_0 = (RuleCall)cNameAssignment_0_0_1.eContents().get(0);
		private final Keyword cAsteriskKeyword_0_0_2 = (Keyword)cGroup_0_0.eContents().get(2);
		private final Group cGroup_0_1 = (Group)cAlternatives_0.eContents().get(1);
		private final Action cUnicastAction_0_1_0 = (Action)cGroup_0_1.eContents().get(0);
		private final Assignment cNameAssignment_0_1_1 = (Assignment)cGroup_0_1.eContents().get(1);
		private final RuleCall cNameLOWERTerminalRuleCall_0_1_1_0 = (RuleCall)cNameAssignment_0_1_1.eContents().get(0);
		private final Assignment cPredicateAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cPredicatePredicateParserRuleCall_1_0 = (RuleCall)cPredicateAssignment_1.eContents().get(0);
		private final Assignment cArgumentsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cArgumentsArgumentsParserRuleCall_2_0 = (RuleCall)cArgumentsAssignment_2.eContents().get(0);
		private final Assignment cUpdatesAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cUpdatesUpdatesParserRuleCall_3_0 = (RuleCall)cUpdatesAssignment_3.eContents().get(0);
		private final Keyword cFullStopKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		/// **  Old Store expressions
		//StoreExpression hidden(ML_COMMENT,SL_COMMENT,WS):
		//	StoreOr ";"
		//;
		//	
		//StoreOr returns StoreExpression hidden(ML_COMMENT,SL_COMMENT,WS):
		//	StoreAnd ({StoreOr.left=current} "||" 
		//		right=StoreAnd
		//	)*
		//;
		//
		//StoreAnd returns StoreExpression hidden(ML_COMMENT,SL_COMMENT,WS):
		//	StoreEquality ({StoreAnd.left=current} "&&" 
		//		right=StoreEquality
		//	)*
		//;
		//
		//StoreEquality returns StoreExpression hidden(ML_COMMENT,SL_COMMENT,WS):
		//	StoreComparison (
		//		{StoreEquality.left=current} op=("=="|"!=")
		//		right=StoreComparison
		//	)*
		//;
		//
		//StoreComparison returns StoreExpression hidden(ML_COMMENT,SL_COMMENT,WS):
		//	StoreSubtraction ({StoreComparison.left=current} op=(">="|"<="|">"|"<") 
		//		right=StoreSubtraction
		//	)*
		//;
		//	
		//StoreSubtraction returns StoreExpression hidden(ML_COMMENT,SL_COMMENT,WS):
		//	StoreAddition ({StoreSub.left=current} '-' 
		//		right=StoreAddition
		//	)*
		//;
		//	
		//StoreAddition returns StoreExpression hidden(ML_COMMENT,SL_COMMENT,WS):
		//	StoreMultiplication ({StorePlu.left=current} '+' 
		//		right=StoreMultiplication
		//	)*
		//;
		//
		//StoreMultiplication returns StoreExpression hidden(ML_COMMENT,SL_COMMENT,WS):
		//	StoreDivision ({StoreMul.left=current} '*' 
		//		right=StoreDivision
		//	)*
		//;
		//	
		//StoreDivision returns StoreExpression hidden(ML_COMMENT,SL_COMMENT,WS): 
		//	StorePrimary ({StoreDiv.left=current} '/' 
		//		right=StorePrimary
		//	)*
		//;
		//
		//StorePrimary returns StoreExpression hidden(ML_COMMENT,SL_COMMENT,WS):
		//	'(' StoreExpression ')' | 
		//	{StoreNot} "!" expression=StorePrimary |
		//	StoreAtomic
		//;
		//
		//StoreAtomic returns StoreExpression hidden(ML_COMMENT,SL_COMMENT,WS):
		//	{DoubleConstant} 	value=Double |
		//	{BoolConstant} 		value=('true'|'false') |
		//	ReferencedStore
		//;
		// ** / //ACTIONS
		//Action hidden(ML_COMMENT, SL_COMMENT, WS):
		//	({Broadcast} name=LOWER "*" | {Unicast} name=LOWER) predicate=Predicate? arguments=Arguments? updates=Updates? ".";
		public ParserRule getRule() { return rule; }

		//({Broadcast} name=LOWER "*" | {Unicast} name=LOWER) predicate=Predicate? arguments=Arguments? updates=Updates? "."
		public Group getGroup() { return cGroup; }

		//{Broadcast} name=LOWER "*" | {Unicast} name=LOWER
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//{Broadcast} name=LOWER "*"
		public Group getGroup_0_0() { return cGroup_0_0; }

		//{Broadcast}
		public Action getBroadcastAction_0_0_0() { return cBroadcastAction_0_0_0; }

		//name=LOWER
		public Assignment getNameAssignment_0_0_1() { return cNameAssignment_0_0_1; }

		//LOWER
		public RuleCall getNameLOWERTerminalRuleCall_0_0_1_0() { return cNameLOWERTerminalRuleCall_0_0_1_0; }

		//"*"
		public Keyword getAsteriskKeyword_0_0_2() { return cAsteriskKeyword_0_0_2; }

		//{Unicast} name=LOWER
		public Group getGroup_0_1() { return cGroup_0_1; }

		//{Unicast}
		public Action getUnicastAction_0_1_0() { return cUnicastAction_0_1_0; }

		//name=LOWER
		public Assignment getNameAssignment_0_1_1() { return cNameAssignment_0_1_1; }

		//LOWER
		public RuleCall getNameLOWERTerminalRuleCall_0_1_1_0() { return cNameLOWERTerminalRuleCall_0_1_1_0; }

		//predicate=Predicate?
		public Assignment getPredicateAssignment_1() { return cPredicateAssignment_1; }

		//Predicate
		public RuleCall getPredicatePredicateParserRuleCall_1_0() { return cPredicatePredicateParserRuleCall_1_0; }

		//arguments=Arguments?
		public Assignment getArgumentsAssignment_2() { return cArgumentsAssignment_2; }

		//Arguments
		public RuleCall getArgumentsArgumentsParserRuleCall_2_0() { return cArgumentsArgumentsParserRuleCall_2_0; }

		//updates=Updates?
		public Assignment getUpdatesAssignment_3() { return cUpdatesAssignment_3; }

		//Updates
		public RuleCall getUpdatesUpdatesParserRuleCall_3_0() { return cUpdatesUpdatesParserRuleCall_3_0; }

		//"."
		public Keyword getFullStopKeyword_4() { return cFullStopKeyword_4; }
	}

	public class PredicateElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Predicate");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cPredicateAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cPredicateAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cPredicatePredicateExpressionParserRuleCall_2_0 = (RuleCall)cPredicateAssignment_2.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		////PREDICATE
		//Predicate hidden(ML_COMMENT, SL_COMMENT, WS):
		//	{Predicate} "[" predicate=PredicateExpression "]";
		public ParserRule getRule() { return rule; }

		//{Predicate} "[" predicate=PredicateExpression "]"
		public Group getGroup() { return cGroup; }

		//{Predicate}
		public Action getPredicateAction_0() { return cPredicateAction_0; }

		//"["
		public Keyword getLeftSquareBracketKeyword_1() { return cLeftSquareBracketKeyword_1; }

		//predicate=PredicateExpression
		public Assignment getPredicateAssignment_2() { return cPredicateAssignment_2; }

		//PredicateExpression
		public RuleCall getPredicatePredicateExpressionParserRuleCall_2_0() { return cPredicatePredicateExpressionParserRuleCall_2_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_3() { return cRightSquareBracketKeyword_3; }
	}

	public class PredicateExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PredicateExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPredicateOrParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cSemicolonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//PredicateExpression hidden(ML_COMMENT, SL_COMMENT, WS):
		//	PredicateOr ";";
		public ParserRule getRule() { return rule; }

		//PredicateOr ";"
		public Group getGroup() { return cGroup; }

		//PredicateOr
		public RuleCall getPredicateOrParserRuleCall_0() { return cPredicateOrParserRuleCall_0; }

		//";"
		public Keyword getSemicolonKeyword_1() { return cSemicolonKeyword_1; }
	}

	public class PredicateOrElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PredicateOr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPredicateAndParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cPredicateOrLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cVerticalLineVerticalLineKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightPredicateAndParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//PredicateOr returns PredicateExpression hidden(ML_COMMENT, SL_COMMENT, WS):
		//	PredicateAnd ({PredicateOr.left=current} "||" right=PredicateAnd)*;
		public ParserRule getRule() { return rule; }

		//PredicateAnd ({PredicateOr.left=current} "||" right=PredicateAnd)*
		public Group getGroup() { return cGroup; }

		//PredicateAnd
		public RuleCall getPredicateAndParserRuleCall_0() { return cPredicateAndParserRuleCall_0; }

		//({PredicateOr.left=current} "||" right=PredicateAnd)*
		public Group getGroup_1() { return cGroup_1; }

		//{PredicateOr.left=current}
		public Action getPredicateOrLeftAction_1_0() { return cPredicateOrLeftAction_1_0; }

		//"||"
		public Keyword getVerticalLineVerticalLineKeyword_1_1() { return cVerticalLineVerticalLineKeyword_1_1; }

		//right=PredicateAnd
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//PredicateAnd
		public RuleCall getRightPredicateAndParserRuleCall_1_2_0() { return cRightPredicateAndParserRuleCall_1_2_0; }
	}

	public class PredicateAndElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PredicateAnd");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPredicateEqualityParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cPredicateAndLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cAmpersandAmpersandKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightPredicateEqualityParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//PredicateAnd returns PredicateExpression hidden(ML_COMMENT, SL_COMMENT, WS):
		//	PredicateEquality ({PredicateAnd.left=current} "&&" right=PredicateEquality)*;
		public ParserRule getRule() { return rule; }

		//PredicateEquality ({PredicateAnd.left=current} "&&" right=PredicateEquality)*
		public Group getGroup() { return cGroup; }

		//PredicateEquality
		public RuleCall getPredicateEqualityParserRuleCall_0() { return cPredicateEqualityParserRuleCall_0; }

		//({PredicateAnd.left=current} "&&" right=PredicateEquality)*
		public Group getGroup_1() { return cGroup_1; }

		//{PredicateAnd.left=current}
		public Action getPredicateAndLeftAction_1_0() { return cPredicateAndLeftAction_1_0; }

		//"&&"
		public Keyword getAmpersandAmpersandKeyword_1_1() { return cAmpersandAmpersandKeyword_1_1; }

		//right=PredicateEquality
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//PredicateEquality
		public RuleCall getRightPredicateEqualityParserRuleCall_1_2_0() { return cRightPredicateEqualityParserRuleCall_1_2_0; }
	}

	public class PredicateEqualityElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PredicateEquality");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPredicateComparisonParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cPredicateEqualityLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cOpAlternatives_1_1_0 = (Alternatives)cOpAssignment_1_1.eContents().get(0);
		private final Keyword cOpEqualsSignEqualsSignKeyword_1_1_0_0 = (Keyword)cOpAlternatives_1_1_0.eContents().get(0);
		private final Keyword cOpExclamationMarkEqualsSignKeyword_1_1_0_1 = (Keyword)cOpAlternatives_1_1_0.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightPredicateComparisonParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//PredicateEquality returns PredicateExpression hidden(ML_COMMENT, SL_COMMENT, WS):
		//	PredicateComparison ({PredicateEquality.left=current} op=("==" | "!=") right=PredicateComparison)*;
		public ParserRule getRule() { return rule; }

		//PredicateComparison ({PredicateEquality.left=current} op=("==" | "!=") right=PredicateComparison)*
		public Group getGroup() { return cGroup; }

		//PredicateComparison
		public RuleCall getPredicateComparisonParserRuleCall_0() { return cPredicateComparisonParserRuleCall_0; }

		//({PredicateEquality.left=current} op=("==" | "!=") right=PredicateComparison)*
		public Group getGroup_1() { return cGroup_1; }

		//{PredicateEquality.left=current}
		public Action getPredicateEqualityLeftAction_1_0() { return cPredicateEqualityLeftAction_1_0; }

		//op=("==" | "!=")
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//"==" | "!="
		public Alternatives getOpAlternatives_1_1_0() { return cOpAlternatives_1_1_0; }

		//"=="
		public Keyword getOpEqualsSignEqualsSignKeyword_1_1_0_0() { return cOpEqualsSignEqualsSignKeyword_1_1_0_0; }

		//"!="
		public Keyword getOpExclamationMarkEqualsSignKeyword_1_1_0_1() { return cOpExclamationMarkEqualsSignKeyword_1_1_0_1; }

		//right=PredicateComparison
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//PredicateComparison
		public RuleCall getRightPredicateComparisonParserRuleCall_1_2_0() { return cRightPredicateComparisonParserRuleCall_1_2_0; }
	}

	public class PredicateComparisonElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PredicateComparison");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPredicateSubtractionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cPredicateComparisonLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cOpAlternatives_1_1_0 = (Alternatives)cOpAssignment_1_1.eContents().get(0);
		private final Keyword cOpGreaterThanSignEqualsSignKeyword_1_1_0_0 = (Keyword)cOpAlternatives_1_1_0.eContents().get(0);
		private final Keyword cOpLessThanSignEqualsSignKeyword_1_1_0_1 = (Keyword)cOpAlternatives_1_1_0.eContents().get(1);
		private final Keyword cOpGreaterThanSignKeyword_1_1_0_2 = (Keyword)cOpAlternatives_1_1_0.eContents().get(2);
		private final Keyword cOpLessThanSignKeyword_1_1_0_3 = (Keyword)cOpAlternatives_1_1_0.eContents().get(3);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightPredicateSubtractionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//PredicateComparison returns PredicateExpression hidden(ML_COMMENT, SL_COMMENT, WS):
		//	PredicateSubtraction ({PredicateComparison.left=current} op=(">=" | "<=" | ">" | "<") right=PredicateSubtraction)*;
		public ParserRule getRule() { return rule; }

		//PredicateSubtraction ({PredicateComparison.left=current} op=(">=" | "<=" | ">" | "<") right=PredicateSubtraction)*
		public Group getGroup() { return cGroup; }

		//PredicateSubtraction
		public RuleCall getPredicateSubtractionParserRuleCall_0() { return cPredicateSubtractionParserRuleCall_0; }

		//({PredicateComparison.left=current} op=(">=" | "<=" | ">" | "<") right=PredicateSubtraction)*
		public Group getGroup_1() { return cGroup_1; }

		//{PredicateComparison.left=current}
		public Action getPredicateComparisonLeftAction_1_0() { return cPredicateComparisonLeftAction_1_0; }

		//op=(">=" | "<=" | ">" | "<")
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//">=" | "<=" | ">" | "<"
		public Alternatives getOpAlternatives_1_1_0() { return cOpAlternatives_1_1_0; }

		//">="
		public Keyword getOpGreaterThanSignEqualsSignKeyword_1_1_0_0() { return cOpGreaterThanSignEqualsSignKeyword_1_1_0_0; }

		//"<="
		public Keyword getOpLessThanSignEqualsSignKeyword_1_1_0_1() { return cOpLessThanSignEqualsSignKeyword_1_1_0_1; }

		//">"
		public Keyword getOpGreaterThanSignKeyword_1_1_0_2() { return cOpGreaterThanSignKeyword_1_1_0_2; }

		//"<"
		public Keyword getOpLessThanSignKeyword_1_1_0_3() { return cOpLessThanSignKeyword_1_1_0_3; }

		//right=PredicateSubtraction
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//PredicateSubtraction
		public RuleCall getRightPredicateSubtractionParserRuleCall_1_2_0() { return cRightPredicateSubtractionParserRuleCall_1_2_0; }
	}

	public class PredicateSubtractionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PredicateSubtraction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPredicateAdditionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cPredicateSubLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightPredicateAdditionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//PredicateSubtraction returns PredicateExpression hidden(ML_COMMENT, SL_COMMENT, WS):
		//	PredicateAddition ({PredicateSub.left=current} "-" right=PredicateAddition)*;
		public ParserRule getRule() { return rule; }

		//PredicateAddition ({PredicateSub.left=current} "-" right=PredicateAddition)*
		public Group getGroup() { return cGroup; }

		//PredicateAddition
		public RuleCall getPredicateAdditionParserRuleCall_0() { return cPredicateAdditionParserRuleCall_0; }

		//({PredicateSub.left=current} "-" right=PredicateAddition)*
		public Group getGroup_1() { return cGroup_1; }

		//{PredicateSub.left=current}
		public Action getPredicateSubLeftAction_1_0() { return cPredicateSubLeftAction_1_0; }

		//"-"
		public Keyword getHyphenMinusKeyword_1_1() { return cHyphenMinusKeyword_1_1; }

		//right=PredicateAddition
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//PredicateAddition
		public RuleCall getRightPredicateAdditionParserRuleCall_1_2_0() { return cRightPredicateAdditionParserRuleCall_1_2_0; }
	}

	public class PredicateAdditionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PredicateAddition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPredicateMultiplicationParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cPredicatePluLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cPlusSignKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightPredicateMultiplicationParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//PredicateAddition returns PredicateExpression hidden(ML_COMMENT, SL_COMMENT, WS):
		//	PredicateMultiplication ({PredicatePlu.left=current} "+" right=PredicateMultiplication)*;
		public ParserRule getRule() { return rule; }

		//PredicateMultiplication ({PredicatePlu.left=current} "+" right=PredicateMultiplication)*
		public Group getGroup() { return cGroup; }

		//PredicateMultiplication
		public RuleCall getPredicateMultiplicationParserRuleCall_0() { return cPredicateMultiplicationParserRuleCall_0; }

		//({PredicatePlu.left=current} "+" right=PredicateMultiplication)*
		public Group getGroup_1() { return cGroup_1; }

		//{PredicatePlu.left=current}
		public Action getPredicatePluLeftAction_1_0() { return cPredicatePluLeftAction_1_0; }

		//"+"
		public Keyword getPlusSignKeyword_1_1() { return cPlusSignKeyword_1_1; }

		//right=PredicateMultiplication
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//PredicateMultiplication
		public RuleCall getRightPredicateMultiplicationParserRuleCall_1_2_0() { return cRightPredicateMultiplicationParserRuleCall_1_2_0; }
	}

	public class PredicateMultiplicationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PredicateMultiplication");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPredicateDivisionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cPredicateMulLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cAsteriskKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightPredicateDivisionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//PredicateMultiplication returns PredicateExpression hidden(ML_COMMENT, SL_COMMENT, WS):
		//	PredicateDivision ({PredicateMul.left=current} "*" right=PredicateDivision)*;
		public ParserRule getRule() { return rule; }

		//PredicateDivision ({PredicateMul.left=current} "*" right=PredicateDivision)*
		public Group getGroup() { return cGroup; }

		//PredicateDivision
		public RuleCall getPredicateDivisionParserRuleCall_0() { return cPredicateDivisionParserRuleCall_0; }

		//({PredicateMul.left=current} "*" right=PredicateDivision)*
		public Group getGroup_1() { return cGroup_1; }

		//{PredicateMul.left=current}
		public Action getPredicateMulLeftAction_1_0() { return cPredicateMulLeftAction_1_0; }

		//"*"
		public Keyword getAsteriskKeyword_1_1() { return cAsteriskKeyword_1_1; }

		//right=PredicateDivision
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//PredicateDivision
		public RuleCall getRightPredicateDivisionParserRuleCall_1_2_0() { return cRightPredicateDivisionParserRuleCall_1_2_0; }
	}

	public class PredicateDivisionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PredicateDivision");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPredicatePrimaryParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cPredicateDivLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cSolidusKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightPredicatePrimaryParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//PredicateDivision returns PredicateExpression hidden(ML_COMMENT, SL_COMMENT, WS):
		//	PredicatePrimary ({PredicateDiv.left=current} "/" right=PredicatePrimary)*;
		public ParserRule getRule() { return rule; }

		//PredicatePrimary ({PredicateDiv.left=current} "/" right=PredicatePrimary)*
		public Group getGroup() { return cGroup; }

		//PredicatePrimary
		public RuleCall getPredicatePrimaryParserRuleCall_0() { return cPredicatePrimaryParserRuleCall_0; }

		//({PredicateDiv.left=current} "/" right=PredicatePrimary)*
		public Group getGroup_1() { return cGroup_1; }

		//{PredicateDiv.left=current}
		public Action getPredicateDivLeftAction_1_0() { return cPredicateDivLeftAction_1_0; }

		//"/"
		public Keyword getSolidusKeyword_1_1() { return cSolidusKeyword_1_1; }

		//right=PredicatePrimary
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//PredicatePrimary
		public RuleCall getRightPredicatePrimaryParserRuleCall_1_2_0() { return cRightPredicatePrimaryParserRuleCall_1_2_0; }
	}

	public class PredicatePrimaryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PredicatePrimary");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cPredicateExpressionParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cNotAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cExclamationMarkKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cExpressionAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cExpressionPredicatePrimaryParserRuleCall_1_2_0 = (RuleCall)cExpressionAssignment_1_2.eContents().get(0);
		private final RuleCall cPredicateAtomicParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//PredicatePrimary returns PredicateExpression hidden(ML_COMMENT, SL_COMMENT, WS):
		//	"(" PredicateExpression ")" | {Not} "!" expression=PredicatePrimary | PredicateAtomic;
		public ParserRule getRule() { return rule; }

		//"(" PredicateExpression ")" | {Not} "!" expression=PredicatePrimary | PredicateAtomic
		public Alternatives getAlternatives() { return cAlternatives; }

		//"(" PredicateExpression ")"
		public Group getGroup_0() { return cGroup_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_0_0() { return cLeftParenthesisKeyword_0_0; }

		//PredicateExpression
		public RuleCall getPredicateExpressionParserRuleCall_0_1() { return cPredicateExpressionParserRuleCall_0_1; }

		//")"
		public Keyword getRightParenthesisKeyword_0_2() { return cRightParenthesisKeyword_0_2; }

		//{Not} "!" expression=PredicatePrimary
		public Group getGroup_1() { return cGroup_1; }

		//{Not}
		public Action getNotAction_1_0() { return cNotAction_1_0; }

		//"!"
		public Keyword getExclamationMarkKeyword_1_1() { return cExclamationMarkKeyword_1_1; }

		//expression=PredicatePrimary
		public Assignment getExpressionAssignment_1_2() { return cExpressionAssignment_1_2; }

		//PredicatePrimary
		public RuleCall getExpressionPredicatePrimaryParserRuleCall_1_2_0() { return cExpressionPredicatePrimaryParserRuleCall_1_2_0; }

		//PredicateAtomic
		public RuleCall getPredicateAtomicParserRuleCall_2() { return cPredicateAtomicParserRuleCall_2; }
	}

	public class PredicateAtomicElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PredicateAtomic");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cConstantAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cValueAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cValueNaturalParserRuleCall_0_1_0 = (RuleCall)cValueAssignment_0_1.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cBoolConstantAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cValueAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cValueAlternatives_1_1_0 = (Alternatives)cValueAssignment_1_1.eContents().get(0);
		private final Keyword cValueTrueKeyword_1_1_0_0 = (Keyword)cValueAlternatives_1_1_0.eContents().get(0);
		private final Keyword cValueFalseKeyword_1_1_0_1 = (Keyword)cValueAlternatives_1_1_0.eContents().get(1);
		private final RuleCall cReferencedStoreParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cSelfReferencedStoreParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//PredicateAtomic returns PredicateExpression hidden(ML_COMMENT, SL_COMMENT, WS):
		//	{Constant} value=Natural | {BoolConstant} value=("true" | "false") | ReferencedStore | SelfReferencedStore;
		public ParserRule getRule() { return rule; }

		//{Constant} value=Natural | {BoolConstant} value=("true" | "false") | ReferencedStore | SelfReferencedStore
		public Alternatives getAlternatives() { return cAlternatives; }

		//{Constant} value=Natural
		public Group getGroup_0() { return cGroup_0; }

		//{Constant}
		public Action getConstantAction_0_0() { return cConstantAction_0_0; }

		//value=Natural
		public Assignment getValueAssignment_0_1() { return cValueAssignment_0_1; }

		//Natural
		public RuleCall getValueNaturalParserRuleCall_0_1_0() { return cValueNaturalParserRuleCall_0_1_0; }

		//{BoolConstant} value=("true" | "false")
		public Group getGroup_1() { return cGroup_1; }

		//{BoolConstant}
		public Action getBoolConstantAction_1_0() { return cBoolConstantAction_1_0; }

		//value=("true" | "false")
		public Assignment getValueAssignment_1_1() { return cValueAssignment_1_1; }

		//"true" | "false"
		public Alternatives getValueAlternatives_1_1_0() { return cValueAlternatives_1_1_0; }

		//"true"
		public Keyword getValueTrueKeyword_1_1_0_0() { return cValueTrueKeyword_1_1_0_0; }

		//"false"
		public Keyword getValueFalseKeyword_1_1_0_1() { return cValueFalseKeyword_1_1_0_1; }

		//ReferencedStore
		public RuleCall getReferencedStoreParserRuleCall_2() { return cReferencedStoreParserRuleCall_2; }

		//SelfReferencedStore
		public RuleCall getSelfReferencedStoreParserRuleCall_3() { return cSelfReferencedStoreParserRuleCall_3; }
	}

	public class ArgumentsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Arguments");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Action cInAction_0_1 = (Action)cGroup_0.eContents().get(1);
		private final Assignment cExpressionsAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cExpressionsInArgumentsParserRuleCall_0_2_0 = (RuleCall)cExpressionsAssignment_0_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_0_3 = (Keyword)cGroup_0.eContents().get(3);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cLessThanSignKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Action cOutAction_1_1 = (Action)cGroup_1.eContents().get(1);
		private final Assignment cExpressionsAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cExpressionsOutArgumentsParserRuleCall_1_2_0 = (RuleCall)cExpressionsAssignment_1_2.eContents().get(0);
		private final Keyword cGreaterThanSignKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		
		////ARGUMENTS
		//Arguments hidden(ML_COMMENT, SL_COMMENT, WS):
		//	"(" {In} expressions+=InArguments+ ")" | "<" {Out} expressions+=OutArguments+ ">";
		public ParserRule getRule() { return rule; }

		//"(" {In} expressions+=InArguments+ ")" | "<" {Out} expressions+=OutArguments+ ">"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"(" {In} expressions+=InArguments+ ")"
		public Group getGroup_0() { return cGroup_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_0_0() { return cLeftParenthesisKeyword_0_0; }

		//{In}
		public Action getInAction_0_1() { return cInAction_0_1; }

		//expressions+=InArguments+
		public Assignment getExpressionsAssignment_0_2() { return cExpressionsAssignment_0_2; }

		//InArguments
		public RuleCall getExpressionsInArgumentsParserRuleCall_0_2_0() { return cExpressionsInArgumentsParserRuleCall_0_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_0_3() { return cRightParenthesisKeyword_0_3; }

		//"<" {Out} expressions+=OutArguments+ ">"
		public Group getGroup_1() { return cGroup_1; }

		//"<"
		public Keyword getLessThanSignKeyword_1_0() { return cLessThanSignKeyword_1_0; }

		//{Out}
		public Action getOutAction_1_1() { return cOutAction_1_1; }

		//expressions+=OutArguments+
		public Assignment getExpressionsAssignment_1_2() { return cExpressionsAssignment_1_2; }

		//OutArguments
		public RuleCall getExpressionsOutArgumentsParserRuleCall_1_2_0() { return cExpressionsOutArgumentsParserRuleCall_1_2_0; }

		//">"
		public Keyword getGreaterThanSignKeyword_1_3() { return cGreaterThanSignKeyword_1_3; }
	}

	public class InArgumentsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "InArguments");
		private final RuleCall cVariablesParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//InArguments hidden(ML_COMMENT, SL_COMMENT, WS):
		//	Variables;
		public ParserRule getRule() { return rule; }

		//Variables
		public RuleCall getVariablesParserRuleCall() { return cVariablesParserRuleCall; }
	}

	public class OutArgumentsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "OutArguments");
		private final RuleCall cExpressionsParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//OutArguments hidden(ML_COMMENT, SL_COMMENT, WS):
		//	Expressions;
		public ParserRule getRule() { return rule; }

		//Expressions
		public RuleCall getExpressionsParserRuleCall() { return cExpressionsParserRuleCall; }
	}

	public class ExpressionsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Expressions");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSelfReferencedStoreParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cReferencedStoreParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final Assignment cValueAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cValueNaturalParserRuleCall_2_0 = (RuleCall)cValueAssignment_2.eContents().get(0);
		
		//Expressions hidden(ML_COMMENT, SL_COMMENT, WS):
		//	SelfReferencedStore | ReferencedStore | value=Natural;
		public ParserRule getRule() { return rule; }

		//SelfReferencedStore | ReferencedStore | value=Natural
		public Alternatives getAlternatives() { return cAlternatives; }

		//SelfReferencedStore
		public RuleCall getSelfReferencedStoreParserRuleCall_0() { return cSelfReferencedStoreParserRuleCall_0; }

		//ReferencedStore
		public RuleCall getReferencedStoreParserRuleCall_1() { return cReferencedStoreParserRuleCall_1; }

		//value=Natural
		public Assignment getValueAssignment_2() { return cValueAssignment_2; }

		//Natural
		public RuleCall getValueNaturalParserRuleCall_2_0() { return cValueNaturalParserRuleCall_2_0; }
	}

	public class VariablesElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Variables");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSelfReferencedStoreParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cReferencedStoreParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Variables hidden(ML_COMMENT, SL_COMMENT, WS):
		//	SelfReferencedStore | ReferencedStore;
		public ParserRule getRule() { return rule; }

		//SelfReferencedStore | ReferencedStore
		public Alternatives getAlternatives() { return cAlternatives; }

		//SelfReferencedStore
		public RuleCall getSelfReferencedStoreParserRuleCall_0() { return cSelfReferencedStoreParserRuleCall_0; }

		//ReferencedStore
		public RuleCall getReferencedStoreParserRuleCall_1() { return cReferencedStoreParserRuleCall_1; }
	}

	public class UpdatesElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Updates");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cUpdatesAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cUpdatesAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cUpdatesUpdateParserRuleCall_2_0 = (RuleCall)cUpdatesAssignment_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		////UPDATES
		//Updates hidden(ML_COMMENT, SL_COMMENT, WS):
		//	{Updates} "{" updates+=Update+ "}";
		public ParserRule getRule() { return rule; }

		//{Updates} "{" updates+=Update+ "}"
		public Group getGroup() { return cGroup; }

		//{Updates}
		public Action getUpdatesAction_0() { return cUpdatesAction_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }

		//updates+=Update+
		public Assignment getUpdatesAssignment_2() { return cUpdatesAssignment_2; }

		//Update
		public RuleCall getUpdatesUpdateParserRuleCall_2_0() { return cUpdatesUpdateParserRuleCall_2_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}

	public class UpdateElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Update");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final RuleCall cSingleEventUpdateParserRuleCall_0_0 = (RuleCall)cAlternatives_0.eContents().get(0);
		private final RuleCall cDistributedEventUpdateParserRuleCall_0_1 = (RuleCall)cAlternatives_0.eContents().get(1);
		private final Keyword cSemicolonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//Update hidden(ML_COMMENT, SL_COMMENT, WS):
		//	(SingleEventUpdate | DistributedEventUpdate) ";";
		public ParserRule getRule() { return rule; }

		//(SingleEventUpdate | DistributedEventUpdate) ";"
		public Group getGroup() { return cGroup; }

		//SingleEventUpdate | DistributedEventUpdate
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//SingleEventUpdate
		public RuleCall getSingleEventUpdateParserRuleCall_0_0() { return cSingleEventUpdateParserRuleCall_0_0; }

		//DistributedEventUpdate
		public RuleCall getDistributedEventUpdateParserRuleCall_0_1() { return cDistributedEventUpdateParserRuleCall_0_1; }

		//";"
		public Keyword getSemicolonKeyword_1() { return cSemicolonKeyword_1; }
	}

	public class SingleEventUpdateElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SingleEventUpdate");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cLocalSingleEventUpdateAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameSelfReferencedStoreParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cColonEqualsSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cExpressionAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cExpressionUpdateExpressionParserRuleCall_3_0 = (RuleCall)cExpressionAssignment_3.eContents().get(0);
		
		////{GlobalSingleEventUpdate} name=[Store|LOWER] ":=" expression=ActionExpression
		//SingleEventUpdate hidden(ML_COMMENT, SL_COMMENT, WS):
		//	{LocalSingleEventUpdate} name=SelfReferencedStore ":=" expression= // | 
		//	UpdateExpression;
		public ParserRule getRule() { return rule; }

		//{LocalSingleEventUpdate} name=SelfReferencedStore ":=" expression= // | 
		//UpdateExpression
		public Group getGroup() { return cGroup; }

		//{LocalSingleEventUpdate}
		public Action getLocalSingleEventUpdateAction_0() { return cLocalSingleEventUpdateAction_0; }

		//name=SelfReferencedStore
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//SelfReferencedStore
		public RuleCall getNameSelfReferencedStoreParserRuleCall_1_0() { return cNameSelfReferencedStoreParserRuleCall_1_0; }

		//":="
		public Keyword getColonEqualsSignKeyword_2() { return cColonEqualsSignKeyword_2; }

		//expression= // | 
		//UpdateExpression
		public Assignment getExpressionAssignment_3() { return cExpressionAssignment_3; }

		//// | 
		//UpdateExpression
		public RuleCall getExpressionUpdateExpressionParserRuleCall_3_0() { return cExpressionUpdateExpressionParserRuleCall_3_0; }
	}

	public class DistributedEventUpdateElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DistributedEventUpdate");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cDistributedEventUpdateProbabilityAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Keyword cPrKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final Assignment cDistributionAssignment_0_3 = (Assignment)cGroup_0.eContents().get(3);
		private final RuleCall cDistributionDistributionParserRuleCall_0_3_0 = (RuleCall)cDistributionAssignment_0_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_0_4 = (Keyword)cGroup_0.eContents().get(4);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cDistributedEventUpdateUniformAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cUKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final Assignment cDistributionAssignment_1_3 = (Assignment)cGroup_1.eContents().get(3);
		private final RuleCall cDistributionUniformParserRuleCall_1_3_0 = (RuleCall)cDistributionAssignment_1_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_4 = (Keyword)cGroup_1.eContents().get(4);
		
		//DistributedEventUpdate hidden(ML_COMMENT, SL_COMMENT, WS):
		//	{DistributedEventUpdateProbability} "Pr" "(" distribution+=Distribution+ ")" | {DistributedEventUpdateUniform} "U" "("
		//	distribution+=Uniform ")";
		public ParserRule getRule() { return rule; }

		//{DistributedEventUpdateProbability} "Pr" "(" distribution+=Distribution+ ")" | {DistributedEventUpdateUniform} "U" "("
		//distribution+=Uniform ")"
		public Alternatives getAlternatives() { return cAlternatives; }

		//{DistributedEventUpdateProbability} "Pr" "(" distribution+=Distribution+ ")"
		public Group getGroup_0() { return cGroup_0; }

		//{DistributedEventUpdateProbability}
		public Action getDistributedEventUpdateProbabilityAction_0_0() { return cDistributedEventUpdateProbabilityAction_0_0; }

		//"Pr"
		public Keyword getPrKeyword_0_1() { return cPrKeyword_0_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_0_2() { return cLeftParenthesisKeyword_0_2; }

		//distribution+=Distribution+
		public Assignment getDistributionAssignment_0_3() { return cDistributionAssignment_0_3; }

		//Distribution
		public RuleCall getDistributionDistributionParserRuleCall_0_3_0() { return cDistributionDistributionParserRuleCall_0_3_0; }

		//")"
		public Keyword getRightParenthesisKeyword_0_4() { return cRightParenthesisKeyword_0_4; }

		//{DistributedEventUpdateUniform} "U" "(" distribution+=Uniform ")"
		public Group getGroup_1() { return cGroup_1; }

		//{DistributedEventUpdateUniform}
		public Action getDistributedEventUpdateUniformAction_1_0() { return cDistributedEventUpdateUniformAction_1_0; }

		//"U"
		public Keyword getUKeyword_1_1() { return cUKeyword_1_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_1_2() { return cLeftParenthesisKeyword_1_2; }

		//distribution+=Uniform
		public Assignment getDistributionAssignment_1_3() { return cDistributionAssignment_1_3; }

		//Uniform
		public RuleCall getDistributionUniformParserRuleCall_1_3_0() { return cDistributionUniformParserRuleCall_1_3_0; }

		//")"
		public Keyword getRightParenthesisKeyword_1_4() { return cRightParenthesisKeyword_1_4; }
	}

	public class DistributionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Distribution");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cDistributionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cProbAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cProbDoubleParserRuleCall_1_0 = (RuleCall)cProbAssignment_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cExpressionAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cExpressionUpdateExpressionParserRuleCall_3_0 = (RuleCall)cExpressionAssignment_3.eContents().get(0);
		private final Keyword cSemicolonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//Distribution hidden(ML_COMMENT, SL_COMMENT, WS):
		//	{Distribution} prob=Double ":" expression=UpdateExpression ";";
		public ParserRule getRule() { return rule; }

		//{Distribution} prob=Double ":" expression=UpdateExpression ";"
		public Group getGroup() { return cGroup; }

		//{Distribution}
		public Action getDistributionAction_0() { return cDistributionAction_0; }

		//prob=Double
		public Assignment getProbAssignment_1() { return cProbAssignment_1; }

		//Double
		public RuleCall getProbDoubleParserRuleCall_1_0() { return cProbDoubleParserRuleCall_1_0; }

		//":"
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }

		//expression=UpdateExpression
		public Assignment getExpressionAssignment_3() { return cExpressionAssignment_3; }

		//UpdateExpression
		public RuleCall getExpressionUpdateExpressionParserRuleCall_3_0() { return cExpressionUpdateExpressionParserRuleCall_3_0; }

		//";"
		public Keyword getSemicolonKeyword_4() { return cSemicolonKeyword_4; }
	}

	public class UniformElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Uniform");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cUniformAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cExpressionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExpressionUpdateExpressionParserRuleCall_1_0 = (RuleCall)cExpressionAssignment_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//Uniform hidden(ML_COMMENT, SL_COMMENT, WS):
		//	{Uniform} expression=UpdateExpression ";";
		public ParserRule getRule() { return rule; }

		//{Uniform} expression=UpdateExpression ";"
		public Group getGroup() { return cGroup; }

		//{Uniform}
		public Action getUniformAction_0() { return cUniformAction_0; }

		//expression=UpdateExpression
		public Assignment getExpressionAssignment_1() { return cExpressionAssignment_1; }

		//UpdateExpression
		public RuleCall getExpressionUpdateExpressionParserRuleCall_1_0() { return cExpressionUpdateExpressionParserRuleCall_1_0; }

		//";"
		public Keyword getSemicolonKeyword_2() { return cSemicolonKeyword_2; }
	}

	public class UpdateExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UpdateExpression");
		private final RuleCall cUpdateOrParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//UpdateExpression hidden(ML_COMMENT, SL_COMMENT, WS):
		//	UpdateOr;
		public ParserRule getRule() { return rule; }

		//UpdateOr
		public RuleCall getUpdateOrParserRuleCall() { return cUpdateOrParserRuleCall; }
	}

	public class UpdateOrElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UpdateOr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cUpdateAndParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cUpdateOrLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cVerticalLineVerticalLineKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightUpdateAndParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//UpdateOr returns UpdateExpression hidden(ML_COMMENT, SL_COMMENT, WS):
		//	UpdateAnd ({UpdateOr.left=current} "||" right=UpdateAnd)*;
		public ParserRule getRule() { return rule; }

		//UpdateAnd ({UpdateOr.left=current} "||" right=UpdateAnd)*
		public Group getGroup() { return cGroup; }

		//UpdateAnd
		public RuleCall getUpdateAndParserRuleCall_0() { return cUpdateAndParserRuleCall_0; }

		//({UpdateOr.left=current} "||" right=UpdateAnd)*
		public Group getGroup_1() { return cGroup_1; }

		//{UpdateOr.left=current}
		public Action getUpdateOrLeftAction_1_0() { return cUpdateOrLeftAction_1_0; }

		//"||"
		public Keyword getVerticalLineVerticalLineKeyword_1_1() { return cVerticalLineVerticalLineKeyword_1_1; }

		//right=UpdateAnd
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//UpdateAnd
		public RuleCall getRightUpdateAndParserRuleCall_1_2_0() { return cRightUpdateAndParserRuleCall_1_2_0; }
	}

	public class UpdateAndElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UpdateAnd");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cUpdateEqualityParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cUpdateAndLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cAmpersandAmpersandKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightUpdateEqualityParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//UpdateAnd returns UpdateExpression hidden(ML_COMMENT, SL_COMMENT, WS):
		//	UpdateEquality ({UpdateAnd.left=current} "&&" right=UpdateEquality)*;
		public ParserRule getRule() { return rule; }

		//UpdateEquality ({UpdateAnd.left=current} "&&" right=UpdateEquality)*
		public Group getGroup() { return cGroup; }

		//UpdateEquality
		public RuleCall getUpdateEqualityParserRuleCall_0() { return cUpdateEqualityParserRuleCall_0; }

		//({UpdateAnd.left=current} "&&" right=UpdateEquality)*
		public Group getGroup_1() { return cGroup_1; }

		//{UpdateAnd.left=current}
		public Action getUpdateAndLeftAction_1_0() { return cUpdateAndLeftAction_1_0; }

		//"&&"
		public Keyword getAmpersandAmpersandKeyword_1_1() { return cAmpersandAmpersandKeyword_1_1; }

		//right=UpdateEquality
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//UpdateEquality
		public RuleCall getRightUpdateEqualityParserRuleCall_1_2_0() { return cRightUpdateEqualityParserRuleCall_1_2_0; }
	}

	public class UpdateEqualityElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UpdateEquality");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cUpdateComparisonParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cUpdateEqualityLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cOpAlternatives_1_1_0 = (Alternatives)cOpAssignment_1_1.eContents().get(0);
		private final Keyword cOpEqualsSignEqualsSignKeyword_1_1_0_0 = (Keyword)cOpAlternatives_1_1_0.eContents().get(0);
		private final Keyword cOpExclamationMarkEqualsSignKeyword_1_1_0_1 = (Keyword)cOpAlternatives_1_1_0.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightUpdateComparisonParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//UpdateEquality returns UpdateExpression hidden(ML_COMMENT, SL_COMMENT, WS):
		//	UpdateComparison ({UpdateEquality.left=current} op=("==" | "!=") right=UpdateComparison)*;
		public ParserRule getRule() { return rule; }

		//UpdateComparison ({UpdateEquality.left=current} op=("==" | "!=") right=UpdateComparison)*
		public Group getGroup() { return cGroup; }

		//UpdateComparison
		public RuleCall getUpdateComparisonParserRuleCall_0() { return cUpdateComparisonParserRuleCall_0; }

		//({UpdateEquality.left=current} op=("==" | "!=") right=UpdateComparison)*
		public Group getGroup_1() { return cGroup_1; }

		//{UpdateEquality.left=current}
		public Action getUpdateEqualityLeftAction_1_0() { return cUpdateEqualityLeftAction_1_0; }

		//op=("==" | "!=")
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//"==" | "!="
		public Alternatives getOpAlternatives_1_1_0() { return cOpAlternatives_1_1_0; }

		//"=="
		public Keyword getOpEqualsSignEqualsSignKeyword_1_1_0_0() { return cOpEqualsSignEqualsSignKeyword_1_1_0_0; }

		//"!="
		public Keyword getOpExclamationMarkEqualsSignKeyword_1_1_0_1() { return cOpExclamationMarkEqualsSignKeyword_1_1_0_1; }

		//right=UpdateComparison
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//UpdateComparison
		public RuleCall getRightUpdateComparisonParserRuleCall_1_2_0() { return cRightUpdateComparisonParserRuleCall_1_2_0; }
	}

	public class UpdateComparisonElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UpdateComparison");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cUpdateSubtractionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cUpdateComparisonLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cOpAlternatives_1_1_0 = (Alternatives)cOpAssignment_1_1.eContents().get(0);
		private final Keyword cOpGreaterThanSignEqualsSignKeyword_1_1_0_0 = (Keyword)cOpAlternatives_1_1_0.eContents().get(0);
		private final Keyword cOpLessThanSignEqualsSignKeyword_1_1_0_1 = (Keyword)cOpAlternatives_1_1_0.eContents().get(1);
		private final Keyword cOpGreaterThanSignKeyword_1_1_0_2 = (Keyword)cOpAlternatives_1_1_0.eContents().get(2);
		private final Keyword cOpLessThanSignKeyword_1_1_0_3 = (Keyword)cOpAlternatives_1_1_0.eContents().get(3);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightUpdateSubtractionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//UpdateComparison returns UpdateExpression hidden(ML_COMMENT, SL_COMMENT, WS):
		//	UpdateSubtraction ({UpdateComparison.left=current} op=(">=" | "<=" | ">" | "<") right=UpdateSubtraction)*;
		public ParserRule getRule() { return rule; }

		//UpdateSubtraction ({UpdateComparison.left=current} op=(">=" | "<=" | ">" | "<") right=UpdateSubtraction)*
		public Group getGroup() { return cGroup; }

		//UpdateSubtraction
		public RuleCall getUpdateSubtractionParserRuleCall_0() { return cUpdateSubtractionParserRuleCall_0; }

		//({UpdateComparison.left=current} op=(">=" | "<=" | ">" | "<") right=UpdateSubtraction)*
		public Group getGroup_1() { return cGroup_1; }

		//{UpdateComparison.left=current}
		public Action getUpdateComparisonLeftAction_1_0() { return cUpdateComparisonLeftAction_1_0; }

		//op=(">=" | "<=" | ">" | "<")
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//">=" | "<=" | ">" | "<"
		public Alternatives getOpAlternatives_1_1_0() { return cOpAlternatives_1_1_0; }

		//">="
		public Keyword getOpGreaterThanSignEqualsSignKeyword_1_1_0_0() { return cOpGreaterThanSignEqualsSignKeyword_1_1_0_0; }

		//"<="
		public Keyword getOpLessThanSignEqualsSignKeyword_1_1_0_1() { return cOpLessThanSignEqualsSignKeyword_1_1_0_1; }

		//">"
		public Keyword getOpGreaterThanSignKeyword_1_1_0_2() { return cOpGreaterThanSignKeyword_1_1_0_2; }

		//"<"
		public Keyword getOpLessThanSignKeyword_1_1_0_3() { return cOpLessThanSignKeyword_1_1_0_3; }

		//right=UpdateSubtraction
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//UpdateSubtraction
		public RuleCall getRightUpdateSubtractionParserRuleCall_1_2_0() { return cRightUpdateSubtractionParserRuleCall_1_2_0; }
	}

	public class UpdateSubtractionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UpdateSubtraction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cUpdateAdditionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cUpdateSubLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightUpdateAdditionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//UpdateSubtraction returns UpdateExpression hidden(ML_COMMENT, SL_COMMENT, WS):
		//	UpdateAddition ({UpdateSub.left=current} "-" right=UpdateAddition)*;
		public ParserRule getRule() { return rule; }

		//UpdateAddition ({UpdateSub.left=current} "-" right=UpdateAddition)*
		public Group getGroup() { return cGroup; }

		//UpdateAddition
		public RuleCall getUpdateAdditionParserRuleCall_0() { return cUpdateAdditionParserRuleCall_0; }

		//({UpdateSub.left=current} "-" right=UpdateAddition)*
		public Group getGroup_1() { return cGroup_1; }

		//{UpdateSub.left=current}
		public Action getUpdateSubLeftAction_1_0() { return cUpdateSubLeftAction_1_0; }

		//"-"
		public Keyword getHyphenMinusKeyword_1_1() { return cHyphenMinusKeyword_1_1; }

		//right=UpdateAddition
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//UpdateAddition
		public RuleCall getRightUpdateAdditionParserRuleCall_1_2_0() { return cRightUpdateAdditionParserRuleCall_1_2_0; }
	}

	public class UpdateAdditionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UpdateAddition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cUpdateMultiplicationParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cUpdatePluLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cPlusSignKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightUpdateMultiplicationParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//UpdateAddition returns UpdateExpression hidden(ML_COMMENT, SL_COMMENT, WS):
		//	UpdateMultiplication ({UpdatePlu.left=current} "+" right=UpdateMultiplication)*;
		public ParserRule getRule() { return rule; }

		//UpdateMultiplication ({UpdatePlu.left=current} "+" right=UpdateMultiplication)*
		public Group getGroup() { return cGroup; }

		//UpdateMultiplication
		public RuleCall getUpdateMultiplicationParserRuleCall_0() { return cUpdateMultiplicationParserRuleCall_0; }

		//({UpdatePlu.left=current} "+" right=UpdateMultiplication)*
		public Group getGroup_1() { return cGroup_1; }

		//{UpdatePlu.left=current}
		public Action getUpdatePluLeftAction_1_0() { return cUpdatePluLeftAction_1_0; }

		//"+"
		public Keyword getPlusSignKeyword_1_1() { return cPlusSignKeyword_1_1; }

		//right=UpdateMultiplication
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//UpdateMultiplication
		public RuleCall getRightUpdateMultiplicationParserRuleCall_1_2_0() { return cRightUpdateMultiplicationParserRuleCall_1_2_0; }
	}

	public class UpdateMultiplicationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UpdateMultiplication");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cUpdateDivisionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cUpdateMulLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cAsteriskKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightUpdateDivisionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//UpdateMultiplication returns UpdateExpression hidden(ML_COMMENT, SL_COMMENT, WS):
		//	UpdateDivision ({UpdateMul.left=current} "*" right=UpdateDivision)*;
		public ParserRule getRule() { return rule; }

		//UpdateDivision ({UpdateMul.left=current} "*" right=UpdateDivision)*
		public Group getGroup() { return cGroup; }

		//UpdateDivision
		public RuleCall getUpdateDivisionParserRuleCall_0() { return cUpdateDivisionParserRuleCall_0; }

		//({UpdateMul.left=current} "*" right=UpdateDivision)*
		public Group getGroup_1() { return cGroup_1; }

		//{UpdateMul.left=current}
		public Action getUpdateMulLeftAction_1_0() { return cUpdateMulLeftAction_1_0; }

		//"*"
		public Keyword getAsteriskKeyword_1_1() { return cAsteriskKeyword_1_1; }

		//right=UpdateDivision
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//UpdateDivision
		public RuleCall getRightUpdateDivisionParserRuleCall_1_2_0() { return cRightUpdateDivisionParserRuleCall_1_2_0; }
	}

	public class UpdateDivisionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UpdateDivision");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cUpdatePrimaryParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cUpdateDivLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cSolidusKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightUpdatePrimaryParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//UpdateDivision returns UpdateExpression hidden(ML_COMMENT, SL_COMMENT, WS):
		//	UpdatePrimary ({UpdateDiv.left=current} "/" right=UpdatePrimary)*;
		public ParserRule getRule() { return rule; }

		//UpdatePrimary ({UpdateDiv.left=current} "/" right=UpdatePrimary)*
		public Group getGroup() { return cGroup; }

		//UpdatePrimary
		public RuleCall getUpdatePrimaryParserRuleCall_0() { return cUpdatePrimaryParserRuleCall_0; }

		//({UpdateDiv.left=current} "/" right=UpdatePrimary)*
		public Group getGroup_1() { return cGroup_1; }

		//{UpdateDiv.left=current}
		public Action getUpdateDivLeftAction_1_0() { return cUpdateDivLeftAction_1_0; }

		//"/"
		public Keyword getSolidusKeyword_1_1() { return cSolidusKeyword_1_1; }

		//right=UpdatePrimary
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//UpdatePrimary
		public RuleCall getRightUpdatePrimaryParserRuleCall_1_2_0() { return cRightUpdatePrimaryParserRuleCall_1_2_0; }
	}

	public class UpdatePrimaryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UpdatePrimary");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cUpdateExpressionParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cUpdateNotAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cExclamationMarkKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cExpressionAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cExpressionUpdatePrimaryParserRuleCall_1_2_0 = (RuleCall)cExpressionAssignment_1_2.eContents().get(0);
		private final RuleCall cUpdateAtomicParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//UpdatePrimary returns UpdateExpression hidden(ML_COMMENT, SL_COMMENT, WS):
		//	"(" UpdateExpression ")" | {UpdateNot} "!" expression=UpdatePrimary | UpdateAtomic;
		public ParserRule getRule() { return rule; }

		//"(" UpdateExpression ")" | {UpdateNot} "!" expression=UpdatePrimary | UpdateAtomic
		public Alternatives getAlternatives() { return cAlternatives; }

		//"(" UpdateExpression ")"
		public Group getGroup_0() { return cGroup_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_0_0() { return cLeftParenthesisKeyword_0_0; }

		//UpdateExpression
		public RuleCall getUpdateExpressionParserRuleCall_0_1() { return cUpdateExpressionParserRuleCall_0_1; }

		//")"
		public Keyword getRightParenthesisKeyword_0_2() { return cRightParenthesisKeyword_0_2; }

		//{UpdateNot} "!" expression=UpdatePrimary
		public Group getGroup_1() { return cGroup_1; }

		//{UpdateNot}
		public Action getUpdateNotAction_1_0() { return cUpdateNotAction_1_0; }

		//"!"
		public Keyword getExclamationMarkKeyword_1_1() { return cExclamationMarkKeyword_1_1; }

		//expression=UpdatePrimary
		public Assignment getExpressionAssignment_1_2() { return cExpressionAssignment_1_2; }

		//UpdatePrimary
		public RuleCall getExpressionUpdatePrimaryParserRuleCall_1_2_0() { return cExpressionUpdatePrimaryParserRuleCall_1_2_0; }

		//UpdateAtomic
		public RuleCall getUpdateAtomicParserRuleCall_2() { return cUpdateAtomicParserRuleCall_2; }
	}

	public class UpdateAtomicElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UpdateAtomic");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cConstantAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cValueAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cValueNaturalParserRuleCall_0_1_0 = (RuleCall)cValueAssignment_0_1.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cBoolConstantAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cValueAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cValueAlternatives_1_1_0 = (Alternatives)cValueAssignment_1_1.eContents().get(0);
		private final Keyword cValueTrueKeyword_1_1_0_0 = (Keyword)cValueAlternatives_1_1_0.eContents().get(0);
		private final Keyword cValueFalseKeyword_1_1_0_1 = (Keyword)cValueAlternatives_1_1_0.eContents().get(1);
		private final RuleCall cReferencedStoreParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cSelfReferencedStoreParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//UpdateAtomic returns UpdateExpression hidden(ML_COMMENT, SL_COMMENT, WS):
		//	{Constant} value=Natural | {BoolConstant} value=("true" | "false") | ReferencedStore | SelfReferencedStore;
		public ParserRule getRule() { return rule; }

		//{Constant} value=Natural | {BoolConstant} value=("true" | "false") | ReferencedStore | SelfReferencedStore
		public Alternatives getAlternatives() { return cAlternatives; }

		//{Constant} value=Natural
		public Group getGroup_0() { return cGroup_0; }

		//{Constant}
		public Action getConstantAction_0_0() { return cConstantAction_0_0; }

		//value=Natural
		public Assignment getValueAssignment_0_1() { return cValueAssignment_0_1; }

		//Natural
		public RuleCall getValueNaturalParserRuleCall_0_1_0() { return cValueNaturalParserRuleCall_0_1_0; }

		//{BoolConstant} value=("true" | "false")
		public Group getGroup_1() { return cGroup_1; }

		//{BoolConstant}
		public Action getBoolConstantAction_1_0() { return cBoolConstantAction_1_0; }

		//value=("true" | "false")
		public Assignment getValueAssignment_1_1() { return cValueAssignment_1_1; }

		//"true" | "false"
		public Alternatives getValueAlternatives_1_1_0() { return cValueAlternatives_1_1_0; }

		//"true"
		public Keyword getValueTrueKeyword_1_1_0_0() { return cValueTrueKeyword_1_1_0_0; }

		//"false"
		public Keyword getValueFalseKeyword_1_1_0_1() { return cValueFalseKeyword_1_1_0_1; }

		//ReferencedStore
		public RuleCall getReferencedStoreParserRuleCall_2() { return cReferencedStoreParserRuleCall_2; }

		//SelfReferencedStore
		public RuleCall getSelfReferencedStoreParserRuleCall_3() { return cSelfReferencedStoreParserRuleCall_3; }
	}

	public class ProcessElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Process");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameUPPERTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cValueAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValueProcessExpressionParserRuleCall_2_0 = (RuleCall)cValueAssignment_2.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		////PROCESSES
		//Process hidden(ML_COMMENT, SL_COMMENT, WS):
		//	name=UPPER "=" value=ProcessExpression ";";
		public ParserRule getRule() { return rule; }

		//name=UPPER "=" value=ProcessExpression ";"
		public Group getGroup() { return cGroup; }

		//name=UPPER
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//UPPER
		public RuleCall getNameUPPERTerminalRuleCall_0_0() { return cNameUPPERTerminalRuleCall_0_0; }

		//"="
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }

		//value=ProcessExpression
		public Assignment getValueAssignment_2() { return cValueAssignment_2; }

		//ProcessExpression
		public RuleCall getValueProcessExpressionParserRuleCall_2_0() { return cValueProcessExpressionParserRuleCall_2_0; }

		//";"
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}

	public class ProcessExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ProcessExpression");
		private final RuleCall cParallelParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//ProcessExpression hidden(ML_COMMENT, SL_COMMENT, WS):
		//	Parallel;
		public ParserRule getRule() { return rule; }

		//Parallel
		public RuleCall getParallelParserRuleCall() { return cParallelParserRuleCall; }
	}

	public class ParallelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Parallel");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cChoiceParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cParallelLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cVerticalLineKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightChoiceParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Parallel returns ProcessExpression hidden(ML_COMMENT, SL_COMMENT, WS):
		//	Choice ({Parallel.left=current} "|" right=Choice)*;
		public ParserRule getRule() { return rule; }

		//Choice ({Parallel.left=current} "|" right=Choice)*
		public Group getGroup() { return cGroup; }

		//Choice
		public RuleCall getChoiceParserRuleCall_0() { return cChoiceParserRuleCall_0; }

		//({Parallel.left=current} "|" right=Choice)*
		public Group getGroup_1() { return cGroup_1; }

		//{Parallel.left=current}
		public Action getParallelLeftAction_1_0() { return cParallelLeftAction_1_0; }

		//"|"
		public Keyword getVerticalLineKeyword_1_1() { return cVerticalLineKeyword_1_1; }

		//right=Choice
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//Choice
		public RuleCall getRightChoiceParserRuleCall_1_2_0() { return cRightChoiceParserRuleCall_1_2_0; }
	}

	public class ChoiceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Choice");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPrimaryProcessParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cChoiceLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cPlusSignKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightPrimaryProcessParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Choice returns ProcessExpression hidden(ML_COMMENT, SL_COMMENT, WS):
		//	PrimaryProcess ({Choice.left=current} "+" right=PrimaryProcess)*;
		public ParserRule getRule() { return rule; }

		//PrimaryProcess ({Choice.left=current} "+" right=PrimaryProcess)*
		public Group getGroup() { return cGroup; }

		//PrimaryProcess
		public RuleCall getPrimaryProcessParserRuleCall_0() { return cPrimaryProcessParserRuleCall_0; }

		//({Choice.left=current} "+" right=PrimaryProcess)*
		public Group getGroup_1() { return cGroup_1; }

		//{Choice.left=current}
		public Action getChoiceLeftAction_1_0() { return cChoiceLeftAction_1_0; }

		//"+"
		public Keyword getPlusSignKeyword_1_1() { return cPlusSignKeyword_1_1; }

		//right=PrimaryProcess
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//PrimaryProcess
		public RuleCall getRightPrimaryProcessParserRuleCall_1_2_0() { return cRightPrimaryProcessParserRuleCall_1_2_0; }
	}

	public class PrimaryProcessElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PrimaryProcess");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cLeafAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cValueAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final Keyword cValueNilKeyword_0_1_0 = (Keyword)cValueAssignment_0_1.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cLeafAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cValueAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cValueKillKeyword_1_1_0 = (Keyword)cValueAssignment_1_1.eContents().get(0);
		private final RuleCall cPredicateProcessParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cActionProcessParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final Group cGroup_4 = (Group)cAlternatives.eContents().get(4);
		private final Action cProcessReferenceAction_4_0 = (Action)cGroup_4.eContents().get(0);
		private final Assignment cValueAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final CrossReference cValueProcessCrossReference_4_1_0 = (CrossReference)cValueAssignment_4_1.eContents().get(0);
		private final RuleCall cValueProcessUPPERTerminalRuleCall_4_1_0_1 = (RuleCall)cValueProcessCrossReference_4_1_0.eContents().get(1);
		
		//PrimaryProcess returns ProcessExpression hidden(ML_COMMENT, SL_COMMENT, WS):
		//	{Leaf} value="nil" | {Leaf} value="kill" | PredicateProcess | ActionProcess | {ProcessReference}
		//	value=[Process|UPPER];
		public ParserRule getRule() { return rule; }

		//{Leaf} value="nil" | {Leaf} value="kill" | PredicateProcess | ActionProcess | {ProcessReference} value=[Process|UPPER]
		public Alternatives getAlternatives() { return cAlternatives; }

		//{Leaf} value="nil"
		public Group getGroup_0() { return cGroup_0; }

		//{Leaf}
		public Action getLeafAction_0_0() { return cLeafAction_0_0; }

		//value="nil"
		public Assignment getValueAssignment_0_1() { return cValueAssignment_0_1; }

		//"nil"
		public Keyword getValueNilKeyword_0_1_0() { return cValueNilKeyword_0_1_0; }

		//{Leaf} value="kill"
		public Group getGroup_1() { return cGroup_1; }

		//{Leaf}
		public Action getLeafAction_1_0() { return cLeafAction_1_0; }

		//value="kill"
		public Assignment getValueAssignment_1_1() { return cValueAssignment_1_1; }

		//"kill"
		public Keyword getValueKillKeyword_1_1_0() { return cValueKillKeyword_1_1_0; }

		//PredicateProcess
		public RuleCall getPredicateProcessParserRuleCall_2() { return cPredicateProcessParserRuleCall_2; }

		//ActionProcess
		public RuleCall getActionProcessParserRuleCall_3() { return cActionProcessParserRuleCall_3; }

		//{ProcessReference} value=[Process|UPPER]
		public Group getGroup_4() { return cGroup_4; }

		//{ProcessReference}
		public Action getProcessReferenceAction_4_0() { return cProcessReferenceAction_4_0; }

		//value=[Process|UPPER]
		public Assignment getValueAssignment_4_1() { return cValueAssignment_4_1; }

		//[Process|UPPER]
		public CrossReference getValueProcessCrossReference_4_1_0() { return cValueProcessCrossReference_4_1_0; }

		//UPPER
		public RuleCall getValueProcessUPPERTerminalRuleCall_4_1_0_1() { return cValueProcessUPPERTerminalRuleCall_4_1_0_1; }
	}

	public class PredicateProcessElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PredicateProcess");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cPredicateProcessAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cPredicateAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cPredicatePredicateParserRuleCall_1_0 = (RuleCall)cPredicateAssignment_1.eContents().get(0);
		private final Assignment cValueAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cValueProcessCrossReference_2_0 = (CrossReference)cValueAssignment_2.eContents().get(0);
		private final RuleCall cValueProcessUPPERTerminalRuleCall_2_0_1 = (RuleCall)cValueProcessCrossReference_2_0.eContents().get(1);
		
		//PredicateProcess hidden(ML_COMMENT, SL_COMMENT, WS):
		//	{PredicateProcess} predicate=Predicate value=[Process|UPPER];
		public ParserRule getRule() { return rule; }

		//{PredicateProcess} predicate=Predicate value=[Process|UPPER]
		public Group getGroup() { return cGroup; }

		//{PredicateProcess}
		public Action getPredicateProcessAction_0() { return cPredicateProcessAction_0; }

		//predicate=Predicate
		public Assignment getPredicateAssignment_1() { return cPredicateAssignment_1; }

		//Predicate
		public RuleCall getPredicatePredicateParserRuleCall_1_0() { return cPredicatePredicateParserRuleCall_1_0; }

		//value=[Process|UPPER]
		public Assignment getValueAssignment_2() { return cValueAssignment_2; }

		//[Process|UPPER]
		public CrossReference getValueProcessCrossReference_2_0() { return cValueProcessCrossReference_2_0; }

		//UPPER
		public RuleCall getValueProcessUPPERTerminalRuleCall_2_0_1() { return cValueProcessUPPERTerminalRuleCall_2_0_1; }
	}

	public class ActionProcessElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ActionProcess");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cActionProcessAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cActionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cActionActionParserRuleCall_1_0 = (RuleCall)cActionAssignment_1.eContents().get(0);
		private final Assignment cValueAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cValueProcessCrossReference_2_0 = (CrossReference)cValueAssignment_2.eContents().get(0);
		private final RuleCall cValueProcessUPPERTerminalRuleCall_2_0_1 = (RuleCall)cValueProcessCrossReference_2_0.eContents().get(1);
		
		//ActionProcess hidden(ML_COMMENT, SL_COMMENT, WS):
		//	{ActionProcess} action=Action value=[Process|UPPER];
		public ParserRule getRule() { return rule; }

		//{ActionProcess} action=Action value=[Process|UPPER]
		public Group getGroup() { return cGroup; }

		//{ActionProcess}
		public Action getActionProcessAction_0() { return cActionProcessAction_0; }

		//action=Action
		public Assignment getActionAssignment_1() { return cActionAssignment_1; }

		//Action
		public RuleCall getActionActionParserRuleCall_1_0() { return cActionActionParserRuleCall_1_0; }

		//value=[Process|UPPER]
		public Assignment getValueAssignment_2() { return cValueAssignment_2; }

		//[Process|UPPER]
		public CrossReference getValueProcessCrossReference_2_0() { return cValueProcessCrossReference_2_0; }

		//UPPER
		public RuleCall getValueProcessUPPERTerminalRuleCall_2_0_1() { return cValueProcessUPPERTerminalRuleCall_2_0_1; }
	}

	public class TermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Term");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cNameProcessCrossReference_1_0 = (CrossReference)cNameAssignment_1.eContents().get(0);
		private final RuleCall cNameProcessUPPERTerminalRuleCall_1_0_1 = (RuleCall)cNameProcessCrossReference_1_0.eContents().get(1);
		private final Keyword cCommaKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cLeftCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cStoresAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final CrossReference cStoresStoreCrossReference_4_0 = (CrossReference)cStoresAssignment_4.eContents().get(0);
		private final RuleCall cStoresStoreLOWERTerminalRuleCall_4_0_1 = (RuleCall)cStoresStoreCrossReference_4_0.eContents().get(1);
		private final Keyword cRightCurlyBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Keyword cRightParenthesisKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Keyword cSemicolonKeyword_7 = (Keyword)cGroup.eContents().get(7);
		
		////TERMS
		//Term hidden(ML_COMMENT, SL_COMMENT, WS):
		//	"(" name=[Process|UPPER] "," "{" stores+=[Store|LOWER] "}" ")" ";";
		public ParserRule getRule() { return rule; }

		//"(" name=[Process|UPPER] "," "{" stores+=[Store|LOWER] "}" ")" ";"
		public Group getGroup() { return cGroup; }

		//"("
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }

		//name=[Process|UPPER]
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//[Process|UPPER]
		public CrossReference getNameProcessCrossReference_1_0() { return cNameProcessCrossReference_1_0; }

		//UPPER
		public RuleCall getNameProcessUPPERTerminalRuleCall_1_0_1() { return cNameProcessUPPERTerminalRuleCall_1_0_1; }

		//","
		public Keyword getCommaKeyword_2() { return cCommaKeyword_2; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_3() { return cLeftCurlyBracketKeyword_3; }

		//stores+=[Store|LOWER]
		public Assignment getStoresAssignment_4() { return cStoresAssignment_4; }

		//[Store|LOWER]
		public CrossReference getStoresStoreCrossReference_4_0() { return cStoresStoreCrossReference_4_0; }

		//LOWER
		public RuleCall getStoresStoreLOWERTerminalRuleCall_4_0_1() { return cStoresStoreLOWERTerminalRuleCall_4_0_1; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_5() { return cRightCurlyBracketKeyword_5; }

		//")"
		public Keyword getRightParenthesisKeyword_6() { return cRightParenthesisKeyword_6; }

		//";"
		public Keyword getSemicolonKeyword_7() { return cSemicolonKeyword_7; }
	}

	public class DoubleElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Double");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cFullStopKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Alternatives cAlternatives_1_2 = (Alternatives)cGroup_1.eContents().get(2);
		private final Keyword cEKeyword_1_2_0 = (Keyword)cAlternatives_1_2.eContents().get(0);
		private final Group cGroup_1_2_1 = (Group)cAlternatives_1_2.eContents().get(1);
		private final Keyword cEKeyword_1_2_1_0 = (Keyword)cGroup_1_2_1.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_1_2_1_1 = (Keyword)cGroup_1_2_1.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_1_2_1_2 = (RuleCall)cGroup_1_2_1.eContents().get(2);
		
		//Double returns ecore::EDouble:
		//	INT ("." INT ("e" | "E" "-"? INT)?)?;
		public ParserRule getRule() { return rule; }

		//INT ("." INT ("e" | "E" "-"? INT)?)?
		public Group getGroup() { return cGroup; }

		//INT
		public RuleCall getINTTerminalRuleCall_0() { return cINTTerminalRuleCall_0; }

		//("." INT ("e" | "E" "-"? INT)?)?
		public Group getGroup_1() { return cGroup_1; }

		//"."
		public Keyword getFullStopKeyword_1_0() { return cFullStopKeyword_1_0; }

		//INT
		public RuleCall getINTTerminalRuleCall_1_1() { return cINTTerminalRuleCall_1_1; }

		//("e" | "E" "-"? INT)?
		public Alternatives getAlternatives_1_2() { return cAlternatives_1_2; }

		//"e"
		public Keyword getEKeyword_1_2_0() { return cEKeyword_1_2_0; }

		//"E" "-"? INT
		public Group getGroup_1_2_1() { return cGroup_1_2_1; }

		//"E"
		public Keyword getEKeyword_1_2_1_0() { return cEKeyword_1_2_1_0; }

		//"-"?
		public Keyword getHyphenMinusKeyword_1_2_1_1() { return cHyphenMinusKeyword_1_2_1_1; }

		//INT
		public RuleCall getINTTerminalRuleCall_1_2_1_2() { return cINTTerminalRuleCall_1_2_1_2; }
	}

	public class NaturalElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Natural");
		private final RuleCall cNATTerminalRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Natural returns ecore::EInt:
		//	NAT;
		public ParserRule getRule() { return rule; }

		//NAT
		public RuleCall getNATTerminalRuleCall() { return cNATTerminalRuleCall; }
	}
	
	
	private final ModelElements pModel;
	private final StoreElements pStore;
	private final ReferencedStoreElements pReferencedStore;
	private final SelfReferencedStoreElements pSelfReferencedStore;
	private final ActionElements pAction;
	private final PredicateElements pPredicate;
	private final PredicateExpressionElements pPredicateExpression;
	private final PredicateOrElements pPredicateOr;
	private final PredicateAndElements pPredicateAnd;
	private final PredicateEqualityElements pPredicateEquality;
	private final PredicateComparisonElements pPredicateComparison;
	private final PredicateSubtractionElements pPredicateSubtraction;
	private final PredicateAdditionElements pPredicateAddition;
	private final PredicateMultiplicationElements pPredicateMultiplication;
	private final PredicateDivisionElements pPredicateDivision;
	private final PredicatePrimaryElements pPredicatePrimary;
	private final PredicateAtomicElements pPredicateAtomic;
	private final ArgumentsElements pArguments;
	private final InArgumentsElements pInArguments;
	private final OutArgumentsElements pOutArguments;
	private final ExpressionsElements pExpressions;
	private final VariablesElements pVariables;
	private final UpdatesElements pUpdates;
	private final UpdateElements pUpdate;
	private final SingleEventUpdateElements pSingleEventUpdate;
	private final DistributedEventUpdateElements pDistributedEventUpdate;
	private final DistributionElements pDistribution;
	private final UniformElements pUniform;
	private final UpdateExpressionElements pUpdateExpression;
	private final UpdateOrElements pUpdateOr;
	private final UpdateAndElements pUpdateAnd;
	private final UpdateEqualityElements pUpdateEquality;
	private final UpdateComparisonElements pUpdateComparison;
	private final UpdateSubtractionElements pUpdateSubtraction;
	private final UpdateAdditionElements pUpdateAddition;
	private final UpdateMultiplicationElements pUpdateMultiplication;
	private final UpdateDivisionElements pUpdateDivision;
	private final UpdatePrimaryElements pUpdatePrimary;
	private final UpdateAtomicElements pUpdateAtomic;
	private final ProcessElements pProcess;
	private final ProcessExpressionElements pProcessExpression;
	private final ParallelElements pParallel;
	private final ChoiceElements pChoice;
	private final PrimaryProcessElements pPrimaryProcess;
	private final PredicateProcessElements pPredicateProcess;
	private final ActionProcessElements pActionProcess;
	private final TermElements pTerm;
	private final DoubleElements pDouble;
	private final NaturalElements pNatural;
	private final TerminalRule tLOWER;
	private final TerminalRule tUPPER;
	private final TerminalRule tNAT;
	
	private final Grammar grammar;

	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public CASPAGrammarAccess(GrammarProvider grammarProvider,
		TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pModel = new ModelElements();
		this.pStore = new StoreElements();
		this.pReferencedStore = new ReferencedStoreElements();
		this.pSelfReferencedStore = new SelfReferencedStoreElements();
		this.pAction = new ActionElements();
		this.pPredicate = new PredicateElements();
		this.pPredicateExpression = new PredicateExpressionElements();
		this.pPredicateOr = new PredicateOrElements();
		this.pPredicateAnd = new PredicateAndElements();
		this.pPredicateEquality = new PredicateEqualityElements();
		this.pPredicateComparison = new PredicateComparisonElements();
		this.pPredicateSubtraction = new PredicateSubtractionElements();
		this.pPredicateAddition = new PredicateAdditionElements();
		this.pPredicateMultiplication = new PredicateMultiplicationElements();
		this.pPredicateDivision = new PredicateDivisionElements();
		this.pPredicatePrimary = new PredicatePrimaryElements();
		this.pPredicateAtomic = new PredicateAtomicElements();
		this.pArguments = new ArgumentsElements();
		this.pInArguments = new InArgumentsElements();
		this.pOutArguments = new OutArgumentsElements();
		this.pExpressions = new ExpressionsElements();
		this.pVariables = new VariablesElements();
		this.pUpdates = new UpdatesElements();
		this.pUpdate = new UpdateElements();
		this.pSingleEventUpdate = new SingleEventUpdateElements();
		this.pDistributedEventUpdate = new DistributedEventUpdateElements();
		this.pDistribution = new DistributionElements();
		this.pUniform = new UniformElements();
		this.pUpdateExpression = new UpdateExpressionElements();
		this.pUpdateOr = new UpdateOrElements();
		this.pUpdateAnd = new UpdateAndElements();
		this.pUpdateEquality = new UpdateEqualityElements();
		this.pUpdateComparison = new UpdateComparisonElements();
		this.pUpdateSubtraction = new UpdateSubtractionElements();
		this.pUpdateAddition = new UpdateAdditionElements();
		this.pUpdateMultiplication = new UpdateMultiplicationElements();
		this.pUpdateDivision = new UpdateDivisionElements();
		this.pUpdatePrimary = new UpdatePrimaryElements();
		this.pUpdateAtomic = new UpdateAtomicElements();
		this.pProcess = new ProcessElements();
		this.pProcessExpression = new ProcessExpressionElements();
		this.pParallel = new ParallelElements();
		this.pChoice = new ChoiceElements();
		this.pPrimaryProcess = new PrimaryProcessElements();
		this.pPredicateProcess = new PredicateProcessElements();
		this.pActionProcess = new ActionProcessElements();
		this.pTerm = new TermElements();
		this.pDouble = new DoubleElements();
		this.pNatural = new NaturalElements();
		this.tLOWER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "LOWER");
		this.tUPPER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "UPPER");
		this.tNAT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "NAT");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("eu.quanticol.CASPA".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	
	public Grammar getGrammar() {
		return grammar;
	}
	

	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//Model hidden(ML_COMMENT, SL_COMMENT, WS):
	//	stores+=Store+ processes+=Process+ terms+=Term+;
	public ModelElements getModelAccess() {
		return pModel;
	}
	
	public ParserRule getModelRule() {
		return getModelAccess().getRule();
	}

	////STORE
	//Store hidden(ML_COMMENT, SL_COMMENT, WS):
	//	name=LOWER "=" value=Natural ";";
	public StoreElements getStoreAccess() {
		return pStore;
	}
	
	public ParserRule getStoreRule() {
		return getStoreAccess().getRule();
	}

	//ReferencedStore hidden(ML_COMMENT, SL_COMMENT, WS):
	//	{ReferencedStore} name=[Store|LOWER];
	public ReferencedStoreElements getReferencedStoreAccess() {
		return pReferencedStore;
	}
	
	public ParserRule getReferencedStoreRule() {
		return getReferencedStoreAccess().getRule();
	}

	//SelfReferencedStore hidden(ML_COMMENT, SL_COMMENT, WS):
	//	{SelfReferencedStore} "this." name=[Store|LOWER];
	public SelfReferencedStoreElements getSelfReferencedStoreAccess() {
		return pSelfReferencedStore;
	}
	
	public ParserRule getSelfReferencedStoreRule() {
		return getSelfReferencedStoreAccess().getRule();
	}

	/// **  Old Store expressions
	//StoreExpression hidden(ML_COMMENT,SL_COMMENT,WS):
	//	StoreOr ";"
	//;
	//	
	//StoreOr returns StoreExpression hidden(ML_COMMENT,SL_COMMENT,WS):
	//	StoreAnd ({StoreOr.left=current} "||" 
	//		right=StoreAnd
	//	)*
	//;
	//
	//StoreAnd returns StoreExpression hidden(ML_COMMENT,SL_COMMENT,WS):
	//	StoreEquality ({StoreAnd.left=current} "&&" 
	//		right=StoreEquality
	//	)*
	//;
	//
	//StoreEquality returns StoreExpression hidden(ML_COMMENT,SL_COMMENT,WS):
	//	StoreComparison (
	//		{StoreEquality.left=current} op=("=="|"!=")
	//		right=StoreComparison
	//	)*
	//;
	//
	//StoreComparison returns StoreExpression hidden(ML_COMMENT,SL_COMMENT,WS):
	//	StoreSubtraction ({StoreComparison.left=current} op=(">="|"<="|">"|"<") 
	//		right=StoreSubtraction
	//	)*
	//;
	//	
	//StoreSubtraction returns StoreExpression hidden(ML_COMMENT,SL_COMMENT,WS):
	//	StoreAddition ({StoreSub.left=current} '-' 
	//		right=StoreAddition
	//	)*
	//;
	//	
	//StoreAddition returns StoreExpression hidden(ML_COMMENT,SL_COMMENT,WS):
	//	StoreMultiplication ({StorePlu.left=current} '+' 
	//		right=StoreMultiplication
	//	)*
	//;
	//
	//StoreMultiplication returns StoreExpression hidden(ML_COMMENT,SL_COMMENT,WS):
	//	StoreDivision ({StoreMul.left=current} '*' 
	//		right=StoreDivision
	//	)*
	//;
	//	
	//StoreDivision returns StoreExpression hidden(ML_COMMENT,SL_COMMENT,WS): 
	//	StorePrimary ({StoreDiv.left=current} '/' 
	//		right=StorePrimary
	//	)*
	//;
	//
	//StorePrimary returns StoreExpression hidden(ML_COMMENT,SL_COMMENT,WS):
	//	'(' StoreExpression ')' | 
	//	{StoreNot} "!" expression=StorePrimary |
	//	StoreAtomic
	//;
	//
	//StoreAtomic returns StoreExpression hidden(ML_COMMENT,SL_COMMENT,WS):
	//	{DoubleConstant} 	value=Double |
	//	{BoolConstant} 		value=('true'|'false') |
	//	ReferencedStore
	//;
	// ** / //ACTIONS
	//Action hidden(ML_COMMENT, SL_COMMENT, WS):
	//	({Broadcast} name=LOWER "*" | {Unicast} name=LOWER) predicate=Predicate? arguments=Arguments? updates=Updates? ".";
	public ActionElements getActionAccess() {
		return pAction;
	}
	
	public ParserRule getActionRule() {
		return getActionAccess().getRule();
	}

	////PREDICATE
	//Predicate hidden(ML_COMMENT, SL_COMMENT, WS):
	//	{Predicate} "[" predicate=PredicateExpression "]";
	public PredicateElements getPredicateAccess() {
		return pPredicate;
	}
	
	public ParserRule getPredicateRule() {
		return getPredicateAccess().getRule();
	}

	//PredicateExpression hidden(ML_COMMENT, SL_COMMENT, WS):
	//	PredicateOr ";";
	public PredicateExpressionElements getPredicateExpressionAccess() {
		return pPredicateExpression;
	}
	
	public ParserRule getPredicateExpressionRule() {
		return getPredicateExpressionAccess().getRule();
	}

	//PredicateOr returns PredicateExpression hidden(ML_COMMENT, SL_COMMENT, WS):
	//	PredicateAnd ({PredicateOr.left=current} "||" right=PredicateAnd)*;
	public PredicateOrElements getPredicateOrAccess() {
		return pPredicateOr;
	}
	
	public ParserRule getPredicateOrRule() {
		return getPredicateOrAccess().getRule();
	}

	//PredicateAnd returns PredicateExpression hidden(ML_COMMENT, SL_COMMENT, WS):
	//	PredicateEquality ({PredicateAnd.left=current} "&&" right=PredicateEquality)*;
	public PredicateAndElements getPredicateAndAccess() {
		return pPredicateAnd;
	}
	
	public ParserRule getPredicateAndRule() {
		return getPredicateAndAccess().getRule();
	}

	//PredicateEquality returns PredicateExpression hidden(ML_COMMENT, SL_COMMENT, WS):
	//	PredicateComparison ({PredicateEquality.left=current} op=("==" | "!=") right=PredicateComparison)*;
	public PredicateEqualityElements getPredicateEqualityAccess() {
		return pPredicateEquality;
	}
	
	public ParserRule getPredicateEqualityRule() {
		return getPredicateEqualityAccess().getRule();
	}

	//PredicateComparison returns PredicateExpression hidden(ML_COMMENT, SL_COMMENT, WS):
	//	PredicateSubtraction ({PredicateComparison.left=current} op=(">=" | "<=" | ">" | "<") right=PredicateSubtraction)*;
	public PredicateComparisonElements getPredicateComparisonAccess() {
		return pPredicateComparison;
	}
	
	public ParserRule getPredicateComparisonRule() {
		return getPredicateComparisonAccess().getRule();
	}

	//PredicateSubtraction returns PredicateExpression hidden(ML_COMMENT, SL_COMMENT, WS):
	//	PredicateAddition ({PredicateSub.left=current} "-" right=PredicateAddition)*;
	public PredicateSubtractionElements getPredicateSubtractionAccess() {
		return pPredicateSubtraction;
	}
	
	public ParserRule getPredicateSubtractionRule() {
		return getPredicateSubtractionAccess().getRule();
	}

	//PredicateAddition returns PredicateExpression hidden(ML_COMMENT, SL_COMMENT, WS):
	//	PredicateMultiplication ({PredicatePlu.left=current} "+" right=PredicateMultiplication)*;
	public PredicateAdditionElements getPredicateAdditionAccess() {
		return pPredicateAddition;
	}
	
	public ParserRule getPredicateAdditionRule() {
		return getPredicateAdditionAccess().getRule();
	}

	//PredicateMultiplication returns PredicateExpression hidden(ML_COMMENT, SL_COMMENT, WS):
	//	PredicateDivision ({PredicateMul.left=current} "*" right=PredicateDivision)*;
	public PredicateMultiplicationElements getPredicateMultiplicationAccess() {
		return pPredicateMultiplication;
	}
	
	public ParserRule getPredicateMultiplicationRule() {
		return getPredicateMultiplicationAccess().getRule();
	}

	//PredicateDivision returns PredicateExpression hidden(ML_COMMENT, SL_COMMENT, WS):
	//	PredicatePrimary ({PredicateDiv.left=current} "/" right=PredicatePrimary)*;
	public PredicateDivisionElements getPredicateDivisionAccess() {
		return pPredicateDivision;
	}
	
	public ParserRule getPredicateDivisionRule() {
		return getPredicateDivisionAccess().getRule();
	}

	//PredicatePrimary returns PredicateExpression hidden(ML_COMMENT, SL_COMMENT, WS):
	//	"(" PredicateExpression ")" | {Not} "!" expression=PredicatePrimary | PredicateAtomic;
	public PredicatePrimaryElements getPredicatePrimaryAccess() {
		return pPredicatePrimary;
	}
	
	public ParserRule getPredicatePrimaryRule() {
		return getPredicatePrimaryAccess().getRule();
	}

	//PredicateAtomic returns PredicateExpression hidden(ML_COMMENT, SL_COMMENT, WS):
	//	{Constant} value=Natural | {BoolConstant} value=("true" | "false") | ReferencedStore | SelfReferencedStore;
	public PredicateAtomicElements getPredicateAtomicAccess() {
		return pPredicateAtomic;
	}
	
	public ParserRule getPredicateAtomicRule() {
		return getPredicateAtomicAccess().getRule();
	}

	////ARGUMENTS
	//Arguments hidden(ML_COMMENT, SL_COMMENT, WS):
	//	"(" {In} expressions+=InArguments+ ")" | "<" {Out} expressions+=OutArguments+ ">";
	public ArgumentsElements getArgumentsAccess() {
		return pArguments;
	}
	
	public ParserRule getArgumentsRule() {
		return getArgumentsAccess().getRule();
	}

	//InArguments hidden(ML_COMMENT, SL_COMMENT, WS):
	//	Variables;
	public InArgumentsElements getInArgumentsAccess() {
		return pInArguments;
	}
	
	public ParserRule getInArgumentsRule() {
		return getInArgumentsAccess().getRule();
	}

	//OutArguments hidden(ML_COMMENT, SL_COMMENT, WS):
	//	Expressions;
	public OutArgumentsElements getOutArgumentsAccess() {
		return pOutArguments;
	}
	
	public ParserRule getOutArgumentsRule() {
		return getOutArgumentsAccess().getRule();
	}

	//Expressions hidden(ML_COMMENT, SL_COMMENT, WS):
	//	SelfReferencedStore | ReferencedStore | value=Natural;
	public ExpressionsElements getExpressionsAccess() {
		return pExpressions;
	}
	
	public ParserRule getExpressionsRule() {
		return getExpressionsAccess().getRule();
	}

	//Variables hidden(ML_COMMENT, SL_COMMENT, WS):
	//	SelfReferencedStore | ReferencedStore;
	public VariablesElements getVariablesAccess() {
		return pVariables;
	}
	
	public ParserRule getVariablesRule() {
		return getVariablesAccess().getRule();
	}

	////UPDATES
	//Updates hidden(ML_COMMENT, SL_COMMENT, WS):
	//	{Updates} "{" updates+=Update+ "}";
	public UpdatesElements getUpdatesAccess() {
		return pUpdates;
	}
	
	public ParserRule getUpdatesRule() {
		return getUpdatesAccess().getRule();
	}

	//Update hidden(ML_COMMENT, SL_COMMENT, WS):
	//	(SingleEventUpdate | DistributedEventUpdate) ";";
	public UpdateElements getUpdateAccess() {
		return pUpdate;
	}
	
	public ParserRule getUpdateRule() {
		return getUpdateAccess().getRule();
	}

	////{GlobalSingleEventUpdate} name=[Store|LOWER] ":=" expression=ActionExpression
	//SingleEventUpdate hidden(ML_COMMENT, SL_COMMENT, WS):
	//	{LocalSingleEventUpdate} name=SelfReferencedStore ":=" expression= // | 
	//	UpdateExpression;
	public SingleEventUpdateElements getSingleEventUpdateAccess() {
		return pSingleEventUpdate;
	}
	
	public ParserRule getSingleEventUpdateRule() {
		return getSingleEventUpdateAccess().getRule();
	}

	//DistributedEventUpdate hidden(ML_COMMENT, SL_COMMENT, WS):
	//	{DistributedEventUpdateProbability} "Pr" "(" distribution+=Distribution+ ")" | {DistributedEventUpdateUniform} "U" "("
	//	distribution+=Uniform ")";
	public DistributedEventUpdateElements getDistributedEventUpdateAccess() {
		return pDistributedEventUpdate;
	}
	
	public ParserRule getDistributedEventUpdateRule() {
		return getDistributedEventUpdateAccess().getRule();
	}

	//Distribution hidden(ML_COMMENT, SL_COMMENT, WS):
	//	{Distribution} prob=Double ":" expression=UpdateExpression ";";
	public DistributionElements getDistributionAccess() {
		return pDistribution;
	}
	
	public ParserRule getDistributionRule() {
		return getDistributionAccess().getRule();
	}

	//Uniform hidden(ML_COMMENT, SL_COMMENT, WS):
	//	{Uniform} expression=UpdateExpression ";";
	public UniformElements getUniformAccess() {
		return pUniform;
	}
	
	public ParserRule getUniformRule() {
		return getUniformAccess().getRule();
	}

	//UpdateExpression hidden(ML_COMMENT, SL_COMMENT, WS):
	//	UpdateOr;
	public UpdateExpressionElements getUpdateExpressionAccess() {
		return pUpdateExpression;
	}
	
	public ParserRule getUpdateExpressionRule() {
		return getUpdateExpressionAccess().getRule();
	}

	//UpdateOr returns UpdateExpression hidden(ML_COMMENT, SL_COMMENT, WS):
	//	UpdateAnd ({UpdateOr.left=current} "||" right=UpdateAnd)*;
	public UpdateOrElements getUpdateOrAccess() {
		return pUpdateOr;
	}
	
	public ParserRule getUpdateOrRule() {
		return getUpdateOrAccess().getRule();
	}

	//UpdateAnd returns UpdateExpression hidden(ML_COMMENT, SL_COMMENT, WS):
	//	UpdateEquality ({UpdateAnd.left=current} "&&" right=UpdateEquality)*;
	public UpdateAndElements getUpdateAndAccess() {
		return pUpdateAnd;
	}
	
	public ParserRule getUpdateAndRule() {
		return getUpdateAndAccess().getRule();
	}

	//UpdateEquality returns UpdateExpression hidden(ML_COMMENT, SL_COMMENT, WS):
	//	UpdateComparison ({UpdateEquality.left=current} op=("==" | "!=") right=UpdateComparison)*;
	public UpdateEqualityElements getUpdateEqualityAccess() {
		return pUpdateEquality;
	}
	
	public ParserRule getUpdateEqualityRule() {
		return getUpdateEqualityAccess().getRule();
	}

	//UpdateComparison returns UpdateExpression hidden(ML_COMMENT, SL_COMMENT, WS):
	//	UpdateSubtraction ({UpdateComparison.left=current} op=(">=" | "<=" | ">" | "<") right=UpdateSubtraction)*;
	public UpdateComparisonElements getUpdateComparisonAccess() {
		return pUpdateComparison;
	}
	
	public ParserRule getUpdateComparisonRule() {
		return getUpdateComparisonAccess().getRule();
	}

	//UpdateSubtraction returns UpdateExpression hidden(ML_COMMENT, SL_COMMENT, WS):
	//	UpdateAddition ({UpdateSub.left=current} "-" right=UpdateAddition)*;
	public UpdateSubtractionElements getUpdateSubtractionAccess() {
		return pUpdateSubtraction;
	}
	
	public ParserRule getUpdateSubtractionRule() {
		return getUpdateSubtractionAccess().getRule();
	}

	//UpdateAddition returns UpdateExpression hidden(ML_COMMENT, SL_COMMENT, WS):
	//	UpdateMultiplication ({UpdatePlu.left=current} "+" right=UpdateMultiplication)*;
	public UpdateAdditionElements getUpdateAdditionAccess() {
		return pUpdateAddition;
	}
	
	public ParserRule getUpdateAdditionRule() {
		return getUpdateAdditionAccess().getRule();
	}

	//UpdateMultiplication returns UpdateExpression hidden(ML_COMMENT, SL_COMMENT, WS):
	//	UpdateDivision ({UpdateMul.left=current} "*" right=UpdateDivision)*;
	public UpdateMultiplicationElements getUpdateMultiplicationAccess() {
		return pUpdateMultiplication;
	}
	
	public ParserRule getUpdateMultiplicationRule() {
		return getUpdateMultiplicationAccess().getRule();
	}

	//UpdateDivision returns UpdateExpression hidden(ML_COMMENT, SL_COMMENT, WS):
	//	UpdatePrimary ({UpdateDiv.left=current} "/" right=UpdatePrimary)*;
	public UpdateDivisionElements getUpdateDivisionAccess() {
		return pUpdateDivision;
	}
	
	public ParserRule getUpdateDivisionRule() {
		return getUpdateDivisionAccess().getRule();
	}

	//UpdatePrimary returns UpdateExpression hidden(ML_COMMENT, SL_COMMENT, WS):
	//	"(" UpdateExpression ")" | {UpdateNot} "!" expression=UpdatePrimary | UpdateAtomic;
	public UpdatePrimaryElements getUpdatePrimaryAccess() {
		return pUpdatePrimary;
	}
	
	public ParserRule getUpdatePrimaryRule() {
		return getUpdatePrimaryAccess().getRule();
	}

	//UpdateAtomic returns UpdateExpression hidden(ML_COMMENT, SL_COMMENT, WS):
	//	{Constant} value=Natural | {BoolConstant} value=("true" | "false") | ReferencedStore | SelfReferencedStore;
	public UpdateAtomicElements getUpdateAtomicAccess() {
		return pUpdateAtomic;
	}
	
	public ParserRule getUpdateAtomicRule() {
		return getUpdateAtomicAccess().getRule();
	}

	////PROCESSES
	//Process hidden(ML_COMMENT, SL_COMMENT, WS):
	//	name=UPPER "=" value=ProcessExpression ";";
	public ProcessElements getProcessAccess() {
		return pProcess;
	}
	
	public ParserRule getProcessRule() {
		return getProcessAccess().getRule();
	}

	//ProcessExpression hidden(ML_COMMENT, SL_COMMENT, WS):
	//	Parallel;
	public ProcessExpressionElements getProcessExpressionAccess() {
		return pProcessExpression;
	}
	
	public ParserRule getProcessExpressionRule() {
		return getProcessExpressionAccess().getRule();
	}

	//Parallel returns ProcessExpression hidden(ML_COMMENT, SL_COMMENT, WS):
	//	Choice ({Parallel.left=current} "|" right=Choice)*;
	public ParallelElements getParallelAccess() {
		return pParallel;
	}
	
	public ParserRule getParallelRule() {
		return getParallelAccess().getRule();
	}

	//Choice returns ProcessExpression hidden(ML_COMMENT, SL_COMMENT, WS):
	//	PrimaryProcess ({Choice.left=current} "+" right=PrimaryProcess)*;
	public ChoiceElements getChoiceAccess() {
		return pChoice;
	}
	
	public ParserRule getChoiceRule() {
		return getChoiceAccess().getRule();
	}

	//PrimaryProcess returns ProcessExpression hidden(ML_COMMENT, SL_COMMENT, WS):
	//	{Leaf} value="nil" | {Leaf} value="kill" | PredicateProcess | ActionProcess | {ProcessReference}
	//	value=[Process|UPPER];
	public PrimaryProcessElements getPrimaryProcessAccess() {
		return pPrimaryProcess;
	}
	
	public ParserRule getPrimaryProcessRule() {
		return getPrimaryProcessAccess().getRule();
	}

	//PredicateProcess hidden(ML_COMMENT, SL_COMMENT, WS):
	//	{PredicateProcess} predicate=Predicate value=[Process|UPPER];
	public PredicateProcessElements getPredicateProcessAccess() {
		return pPredicateProcess;
	}
	
	public ParserRule getPredicateProcessRule() {
		return getPredicateProcessAccess().getRule();
	}

	//ActionProcess hidden(ML_COMMENT, SL_COMMENT, WS):
	//	{ActionProcess} action=Action value=[Process|UPPER];
	public ActionProcessElements getActionProcessAccess() {
		return pActionProcess;
	}
	
	public ParserRule getActionProcessRule() {
		return getActionProcessAccess().getRule();
	}

	////TERMS
	//Term hidden(ML_COMMENT, SL_COMMENT, WS):
	//	"(" name=[Process|UPPER] "," "{" stores+=[Store|LOWER] "}" ")" ";";
	public TermElements getTermAccess() {
		return pTerm;
	}
	
	public ParserRule getTermRule() {
		return getTermAccess().getRule();
	}

	//Double returns ecore::EDouble:
	//	INT ("." INT ("e" | "E" "-"? INT)?)?;
	public DoubleElements getDoubleAccess() {
		return pDouble;
	}
	
	public ParserRule getDoubleRule() {
		return getDoubleAccess().getRule();
	}

	//Natural returns ecore::EInt:
	//	NAT;
	public NaturalElements getNaturalAccess() {
		return pNatural;
	}
	
	public ParserRule getNaturalRule() {
		return getNaturalAccess().getRule();
	}

	//terminal LOWER:
	//	"a".."z" ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getLOWERRule() {
		return tLOWER;
	} 

	//terminal UPPER:
	//	"A".."Z" ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getUPPERRule() {
		return tUPPER;
	} 

	//terminal NAT:
	//	"0".."9"+;
	public TerminalRule getNATRule() {
		return tNAT;
	} 

	//terminal ID:
	//	"^"? ("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	} 

	//terminal INT returns ecore::EInt:
	//	"0".."9"+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	} 

	//terminal STRING:
	//	"\"" ("\\" . / * 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' * / | !("\\" | "\""))* "\"" | "\'" ("\\" .
	//	/ * 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' * / | !("\\" | "\'"))* "\'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	} 

	//terminal ML_COMMENT:
	//	"/ *"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	} 

	//terminal SL_COMMENT:
	//	"//" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	} 

	//terminal WS:
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	} 
}
